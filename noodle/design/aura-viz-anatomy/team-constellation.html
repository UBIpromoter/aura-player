<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Team Constellation — Star Map</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #030712;
    color: #e5e7eb;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .container {
    display: flex;
    gap: 32px;
    padding: 32px;
    max-width: 960px;
    width: 100%;
    align-items: flex-start;
  }

  .panel-left {
    flex: 1;
    min-width: 280px;
    max-width: 360px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .panel-title {
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #6b7280;
    margin-bottom: 2px;
  }

  .question-card {
    background: #1f2937;
    border-radius: 10px;
    padding: 10px 12px;
    transition: all 0.35s ease;
    border: 1px solid transparent;
  }

  .question-card.answered {
    opacity: 0.55;
    transform: scale(0.98);
  }
  .question-card.answered:hover {
    opacity: 1;
    transform: scale(1);
  }

  .question-label {
    font-size: 12px;
    color: #9ca3af;
    margin-bottom: 7px;
    line-height: 1.3;
  }

  .q-num {
    color: #6366f1;
    font-weight: 700;
    margin-right: 3px;
    font-size: 11px;
  }

  .options {
    display: flex;
    gap: 5px;
  }

  .opt-btn {
    flex: 1;
    padding: 6px 6px;
    font-size: 11px;
    font-weight: 500;
    border: 1px solid #374151;
    border-radius: 6px;
    background: transparent;
    color: #d1d5db;
    cursor: pointer;
    transition: all 0.2s;
    line-height: 1.2;
  }

  .opt-btn:hover {
    border-color: #6366f1;
    color: #fff;
    background: rgba(99,102,241,0.08);
  }

  .opt-btn.selected {
    border-color: #8b5cf6;
    background: rgba(139,92,246,0.18);
    color: #fff;
    box-shadow: 0 0 10px rgba(139,92,246,0.15);
  }

  .reset-btn {
    margin-top: 4px;
    padding: 7px 14px;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    border: 1px solid #374151;
    border-radius: 6px;
    background: transparent;
    color: #6b7280;
    cursor: pointer;
    transition: all 0.2s;
    align-self: flex-start;
  }
  .reset-btn:hover {
    border-color: #ef4444;
    color: #ef4444;
  }

  .panel-right {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    flex-shrink: 0;
  }

  .canvas-wrap {
    width: 400px;
    height: 400px;
    border-radius: 14px;
    overflow: hidden;
    background: #030712;
    position: relative;
  }

  canvas {
    display: block;
    width: 400px;
    height: 400px;
  }

  .viz-label {
    font-size: 11px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #4b5563;
    font-weight: 600;
  }

  .answer-count {
    font-size: 10px;
    color: #374151;
    letter-spacing: 0.08em;
  }

  @media (max-width: 780px) {
    .container {
      flex-direction: column;
      align-items: center;
      padding: 16px;
    }
    .panel-left { max-width: 100%; min-width: 0; }
  }
</style>
</head>
<body>

<div class="container">
  <div class="panel-left">
    <div class="panel-title">10 Questions</div>
    <div id="questions"></div>
    <button class="reset-btn" id="resetBtn">Reset</button>
  </div>

  <div class="panel-right">
    <div class="canvas-wrap">
      <canvas id="constellation" width="800" height="800"></canvas>
    </div>
    <div class="viz-label">Team Constellation &mdash; Star Map</div>
    <div class="answer-count" id="answerCount"></div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ────────────────────────────────────────
  // Questions
  // ────────────────────────────────────────
  const QUESTIONS = [
    { q: 'Which came first?', a: ['The chicken', 'The egg'] },
    { q: 'Better pizza topping:', a: ['Pepperoni', 'Pineapple'] },
    { q: 'In 10 years, most people will\u2026', a: ['Still drive cars', 'Use self-driving cars'] },
    { q: 'Is a hot dog a sandwich?', a: ['Yes, obviously', 'No way'] },
    { q: 'Will humans live on Mars by 2050?', a: ['Yes', 'No'] },
    { q: 'Better superpower:', a: ['Flight', 'Invisibility'] },
    { q: 'Coffee in the morning?', a: ['Yes please', 'Not for me'] },
    { q: 'Dogs or cats?', a: ['Dogs', 'Cats'] },
    { q: 'Will AI replace most jobs?', a: ['Yes, big changes coming', 'No, jobs will adapt'] },
    { q: 'Is water wet?', a: ['Yes', 'No'] },
  ];

  const answers = new Array(10).fill(null);

  // ────────────────────────────────────────
  // DOM setup
  // ────────────────────────────────────────
  const qContainer = document.getElementById('questions');
  QUESTIONS.forEach((item, i) => {
    const card = document.createElement('div');
    card.className = 'question-card';
    card.id = 'qcard-' + i;
    card.innerHTML =
      '<div class="question-label"><span class="q-num">' + (i + 1) + '.</span> ' + item.q + '</div>' +
      '<div class="options">' +
        '<button class="opt-btn" data-q="' + i + '" data-v="0">' + item.a[0] + '</button>' +
        '<button class="opt-btn" data-q="' + i + '" data-v="1">' + item.a[1] + '</button>' +
      '</div>';
    qContainer.appendChild(card);
  });

  document.querySelectorAll('.opt-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var qi = parseInt(btn.dataset.q);
      var vi = parseInt(btn.dataset.v);
      answers[qi] = vi;
      var card = document.getElementById('qcard-' + qi);
      card.classList.add('answered');
      card.querySelectorAll('.opt-btn').forEach(function(b) { b.classList.remove('selected'); });
      btn.classList.add('selected');
      applyAnswers();
    });
  });

  document.getElementById('resetBtn').addEventListener('click', function() {
    answers.fill(null);
    document.querySelectorAll('.question-card').forEach(function(c) { c.classList.remove('answered'); });
    document.querySelectorAll('.opt-btn').forEach(function(b) { b.classList.remove('selected'); });
    applyAnswers();
  });

  // ────────────────────────────────────────
  // Seeded random (deterministic per answer combo)
  // ────────────────────────────────────────
  function mulberry32(seed) {
    return function() {
      seed |= 0; seed = seed + 0x6D2B79F5 | 0;
      var t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function answerSeed() {
    var s = 42;
    for (var i = 0; i < 10; i++) {
      s = s * 31 + (answers[i] === null ? 99 : answers[i]);
    }
    return s;
  }

  // ────────────────────────────────────────
  // Constellation state
  // ────────────────────────────────────────
  var CX = 400, CY = 400;

  // Current (interpolated) parameters
  var cur = {
    pattern: 0,       // 0 = hub, 1 = ring (interpolated)
    spread: 0.5,
    drift: 0.3,
    density: 0.5,
    satellites: 0,    // 0 or 1, interpolated
    nodeScale: 1,     // 1 = large, 0.4 = small
    nodeColorA: [139, 92, 246],   // violet
    nodeColorB: [16, 185, 129],   // emerald
    lineColor: [99, 102, 241],    // indigo
    nodeCount: 9,
    pulse: 0,
  };

  // Target parameters
  var tgt = {};
  Object.keys(cur).forEach(function(k) {
    tgt[k] = Array.isArray(cur[k]) ? cur[k].slice() : cur[k];
  });

  // Nodes
  var MAX_NODES = 30;
  var nodes = [];
  for (var ni = 0; ni < MAX_NODES; ni++) {
    nodes.push({
      x: CX, y: CY, tx: CX, ty: CY,
      r: 0, tr: 0,
      halo: 0, thalo: 0,
      alpha: 0, talpha: 0,
      phase: Math.random() * Math.PI * 2,
      orbitAngle: Math.random() * Math.PI * 2,
      orbitSpeed: (Math.random() - 0.5) * 0.004,
      isSat: false,
    });
  }

  var connections = []; // [i, j, alpha]
  var targetConns = [];

  // ────────────────────────────────────────
  // Apply answers -> target state
  // ────────────────────────────────────────
  function applyAnswers() {
    var a = answers;
    var count = 0;
    for (var i = 0; i < 10; i++) if (a[i] !== null) count++;
    document.getElementById('answerCount').textContent = count > 0 ? count + '/10 answered' : '';

    // Q1: hub vs ring
    tgt.pattern = a[0] === null ? 0 : (a[0] === 0 ? 0 : 1);

    // Q2: spread
    tgt.spread = a[1] === null ? 0.5 : (a[1] === 0 ? 0.25 : 0.9);

    // Q3: drift
    tgt.drift = a[2] === null ? 0.3 : (a[2] === 0 ? 0.1 : 0.7);

    // Q4: density
    tgt.density = a[3] === null ? 0.5 : (a[3] === 0 ? 0.95 : 0.15);

    // Q5: satellites
    tgt.satellites = a[4] === null ? 0 : (a[4] === 0 ? 1 : 0);

    // Q6: node scale
    tgt.nodeScale = a[5] === null ? 1 : (a[5] === 0 ? 1.2 : 0.45);

    // Q7: node colors
    if (a[6] === 1) {
      tgt.nodeColorA = [59, 130, 246];   // blue
      tgt.nodeColorB = [6, 182, 212];    // cyan
    } else {
      tgt.nodeColorA = [139, 92, 246];   // violet
      tgt.nodeColorB = [16, 185, 129];   // emerald
    }

    // Q8: line color
    if (a[7] === 0) {
      tgt.lineColor = [217, 70, 239];    // pink
    } else if (a[7] === 1) {
      tgt.lineColor = [99, 102, 241];    // indigo
    } else {
      tgt.lineColor = [99, 102, 241];    // default indigo
    }

    // Q9: node count
    tgt.nodeCount = a[8] === null ? 9 : (a[8] === 0 ? 14 : 6);

    // Q10: pulse
    tgt.pulse = a[9] === null ? 0 : (a[9] === 0 ? 1 : 0);

    // Generate node targets
    generateTargets();
  }

  function generateTargets() {
    var rng = mulberry32(answerSeed());
    var mainCount = Math.round(tgt.nodeCount);
    var satCount = tgt.satellites > 0.5 ? 6 : 0;
    var total = mainCount + satCount;
    var isRing = tgt.pattern > 0.5;
    var spread = tgt.spread;
    var baseR = 100 + spread * 180;
    var scale = tgt.nodeScale;

    // Center node
    nodes[0].tx = CX;
    nodes[0].ty = CY;
    nodes[0].tr = 8 * scale;
    nodes[0].thalo = 28 * scale;
    nodes[0].talpha = 1;
    nodes[0].isSat = false;

    // Main nodes
    for (var i = 1; i < mainCount; i++) {
      var n = nodes[i];
      var angle = ((i - 1) / (mainCount - 1)) * Math.PI * 2;
      var dist;
      if (isRing) {
        // Ring: nodes on a circle with slight variation
        dist = baseR * (0.85 + 0.15 * Math.sin(i * 2.3));
        angle += Math.PI / (mainCount * 0.8);
      } else {
        // Hub: starburst with varying arm lengths
        var armLen = [0.45, 0.8, 1.0, 0.6, 0.9, 0.5, 1.0, 0.7, 0.85, 0.55, 0.95, 0.65, 0.75, 0.4];
        dist = baseR * (armLen[i % armLen.length]);
      }
      // Add slight randomness (seeded)
      dist += (rng() - 0.5) * 20;
      angle += (rng() - 0.5) * 0.15;

      n.tx = CX + Math.cos(angle) * dist;
      n.ty = CY + Math.sin(angle) * dist;
      n.tr = (3 + rng() * 4) * scale;
      n.thalo = (10 + rng() * 12) * scale;
      n.talpha = 1;
      n.isSat = false;
      n.orbitAngle = angle;
      n.orbitSpeed = (rng() - 0.5) * 0.005;
    }

    // Satellite nodes
    for (var s = 0; s < 6; s++) {
      var si = mainCount + s;
      var sn = nodes[si];
      var sa = (s / 6) * Math.PI * 2 + Math.PI / 12;
      var sd = baseR * 1.45 + 30;
      sn.tx = CX + Math.cos(sa) * sd;
      sn.ty = CY + Math.sin(sa) * sd;
      sn.tr = 2 * scale;
      sn.thalo = 6 * scale;
      sn.talpha = satCount > 0 ? 0.8 : 0;
      sn.isSat = true;
      sn.orbitAngle = sa;
      sn.orbitSpeed = (rng() - 0.5) * 0.003;
    }

    // Fade out unused nodes
    for (var u = total; u < MAX_NODES; u++) {
      nodes[u].talpha = 0;
    }

    // Build connections (deterministic)
    buildConnections(rng, mainCount, satCount);
  }

  function buildConnections(rng, mainCount, satCount) {
    targetConns = [];
    var density = tgt.density;
    var total = mainCount + satCount;

    // Center to main nodes
    for (var i = 1; i < mainCount; i++) {
      var p = density * 0.75 + 0.25; // always connect most to center
      if (rng() < p) {
        targetConns.push([0, i]);
      }
    }

    // Main-to-main (web)
    for (var m1 = 1; m1 < mainCount; m1++) {
      for (var m2 = m1 + 1; m2 < mainCount; m2++) {
        // Neighbors more likely to connect
        var gap = Math.min(Math.abs(m1 - m2), mainCount - Math.abs(m1 - m2));
        var prob = density * (gap <= 2 ? 0.6 : 0.2);
        if (rng() < prob) {
          targetConns.push([m1, m2]);
        }
      }
    }

    // Center to satellites
    if (satCount > 0) {
      for (var cs = 0; cs < satCount; cs++) {
        if (rng() < density * 0.5) {
          targetConns.push([0, mainCount + cs]);
        }
      }
      // Satellite ring
      for (var sr = 0; sr < satCount; sr++) {
        var snext = (sr + 1) % satCount;
        if (rng() < density * 0.7) {
          targetConns.push([mainCount + sr, mainCount + snext]);
        }
      }
      // Some main-to-satellite bridges
      for (var br = 0; br < satCount; br++) {
        var closest = 1 + Math.floor(rng() * (mainCount - 1));
        if (rng() < density * 0.4) {
          targetConns.push([closest, mainCount + br]);
        }
      }
    }

    connections = targetConns;
  }

  // ────────────────────────────────────────
  // Canvas
  // ────────────────────────────────────────
  var canvas = document.getElementById('constellation');
  var ctx = canvas.getContext('2d');

  // Background stars
  var bgStars = [];
  for (var bs = 0; bs < 140; bs++) {
    bgStars.push({
      x: Math.random() * 800,
      y: Math.random() * 800,
      r: Math.random() * 1.0 + 0.2,
      bright: Math.random() * 0.35 + 0.05,
      speed: Math.random() * 0.0015 + 0.0005,
      phase: Math.random() * Math.PI * 2,
    });
  }

  function hexRgb(hex) {
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
  }

  function lrp(a, b, t) { return a + (b - a) * t; }

  var time = 0;

  // ────────────────────────────────────────
  // Animation loop
  // ────────────────────────────────────────
  function frame() {
    time++;
    var dt = 0.035;

    // Interpolate current towards target
    cur.pattern = lrp(cur.pattern, tgt.pattern, dt);
    cur.spread = lrp(cur.spread, tgt.spread, dt);
    cur.drift = lrp(cur.drift, tgt.drift, dt);
    cur.density = lrp(cur.density, tgt.density, dt);
    cur.satellites = lrp(cur.satellites, tgt.satellites, dt);
    cur.nodeScale = lrp(cur.nodeScale, tgt.nodeScale, dt);
    cur.nodeCount = lrp(cur.nodeCount, tgt.nodeCount, dt);
    cur.pulse = lrp(cur.pulse, tgt.pulse, dt);
    for (var c = 0; c < 3; c++) {
      cur.nodeColorA[c] = lrp(cur.nodeColorA[c], tgt.nodeColorA[c], dt);
      cur.nodeColorB[c] = lrp(cur.nodeColorB[c], tgt.nodeColorB[c], dt);
      cur.lineColor[c] = lrp(cur.lineColor[c], tgt.lineColor[c], dt);
    }

    // Interpolate nodes
    var driftSpeed = cur.drift;
    for (var i = 0; i < MAX_NODES; i++) {
      var n = nodes[i];
      n.x = lrp(n.x, n.tx, dt * 0.7);
      n.y = lrp(n.y, n.ty, dt * 0.7);
      n.r = lrp(n.r, n.tr, dt);
      n.halo = lrp(n.halo, n.thalo, dt);
      n.alpha = lrp(n.alpha, n.talpha, dt * 0.5);

      // Orbital drift
      if (i > 0 && n.alpha > 0.01) {
        n.orbitAngle += n.orbitSpeed * driftSpeed;
        var wobbleAmt = 6 + driftSpeed * 30;
        n.x += Math.cos(n.orbitAngle * 0.7 + time * 0.002 * driftSpeed) * wobbleAmt * 0.02;
        n.y += Math.sin(n.orbitAngle * 0.9 + time * 0.0025 * driftSpeed) * wobbleAmt * 0.02;
      }
    }

    // Gentle center-node breathing
    var centerBreath = 1 + 0.06 * Math.sin(time * 0.012);
    nodes[0].r = lrp(nodes[0].r, nodes[0].tr * centerBreath, 0.1);
    nodes[0].halo = lrp(nodes[0].halo, nodes[0].thalo * centerBreath, 0.1);

    render();
    requestAnimationFrame(frame);
  }

  // ────────────────────────────────────────
  // Render
  // ────────────────────────────────────────
  function render() {
    ctx.clearRect(0, 0, 800, 800);
    ctx.fillStyle = '#030712';
    ctx.fillRect(0, 0, 800, 800);

    // Background stars
    for (var si = 0; si < bgStars.length; si++) {
      var s = bgStars[si];
      var tw = 0.5 + 0.5 * Math.sin(time * s.speed + s.phase);
      var sa = s.bright * tw;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(180,200,255,' + sa.toFixed(3) + ')';
      ctx.fill();
    }

    // Connections
    renderConnections();

    // Nodes (back to front: satellites then main then center)
    renderNodes();
  }

  function renderConnections() {
    var lr = Math.round(cur.lineColor[0]);
    var lg = Math.round(cur.lineColor[1]);
    var lb = Math.round(cur.lineColor[2]);

    for (var ci = 0; ci < connections.length; ci++) {
      var pair = connections[ci];
      var na = nodes[pair[0]];
      var nb = nodes[pair[1]];
      var minAlpha = Math.min(na.alpha, nb.alpha);
      if (minAlpha < 0.02) continue;

      var dx = nb.x - na.x;
      var dy = nb.y - na.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      var distFade = Math.max(0, 1 - dist / 500);
      var alpha = distFade * minAlpha * 0.5;
      if (alpha < 0.005) continue;

      // Subtle glow line
      ctx.beginPath();
      ctx.moveTo(na.x, na.y);
      ctx.lineTo(nb.x, nb.y);
      ctx.strokeStyle = 'rgba(' + lr + ',' + lg + ',' + lb + ',' + (alpha * 0.35).toFixed(3) + ')';
      ctx.lineWidth = 3.5;
      ctx.stroke();

      // Crisp core line
      ctx.beginPath();
      ctx.moveTo(na.x, na.y);
      ctx.lineTo(nb.x, nb.y);
      ctx.strokeStyle = 'rgba(' + lr + ',' + lg + ',' + lb + ',' + alpha.toFixed(3) + ')';
      ctx.lineWidth = 0.8;
      ctx.stroke();
    }
  }

  function renderNodes() {
    // Sort: draw low-alpha first, high-alpha last
    var order = [];
    for (var oi = 0; oi < MAX_NODES; oi++) order.push(oi);
    order.sort(function(a, b) { return nodes[a].alpha - nodes[b].alpha; });

    for (var oi2 = 0; oi2 < order.length; oi2++) {
      var idx = order[oi2];
      var n = nodes[idx];
      if (n.alpha < 0.01) continue;

      // Pulse
      var pMult = 1;
      if (cur.pulse > 0.1) {
        var pWave = 0.65 + 0.35 * Math.sin(time * 0.045 + n.phase * 4.5);
        pMult = lrp(1, pWave, cur.pulse);
      }

      // Color: gradient across node index
      var t = MAX_NODES > 1 ? idx / (MAX_NODES - 1) : 0;
      var cr = Math.round(lrp(cur.nodeColorA[0], cur.nodeColorB[0], t));
      var cg = Math.round(lrp(cur.nodeColorA[1], cur.nodeColorB[1], t));
      var cb = Math.round(lrp(cur.nodeColorA[2], cur.nodeColorB[2], t));
      var ba = n.alpha * pMult;

      var hR = n.halo * pMult;
      var cR = n.r * pMult;

      // Layer 1: Outer halo
      if (hR > 1) {
        var g1 = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, hR);
        g1.addColorStop(0, 'rgba(' + cr + ',' + cg + ',' + cb + ',' + (ba * 0.12).toFixed(3) + ')');
        g1.addColorStop(0.45, 'rgba(' + cr + ',' + cg + ',' + cb + ',' + (ba * 0.05).toFixed(3) + ')');
        g1.addColorStop(1, 'rgba(' + cr + ',' + cg + ',' + cb + ',0)');
        ctx.beginPath();
        ctx.arc(n.x, n.y, hR, 0, Math.PI * 2);
        ctx.fillStyle = g1;
        ctx.fill();
      }

      // Layer 2: Mid glow
      if (cR > 0.5) {
        var midR = cR * 2.8;
        var g2 = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, midR);
        g2.addColorStop(0, 'rgba(' + cr + ',' + cg + ',' + cb + ',' + (ba * 0.45).toFixed(3) + ')');
        g2.addColorStop(0.5, 'rgba(' + cr + ',' + cg + ',' + cb + ',' + (ba * 0.12).toFixed(3) + ')');
        g2.addColorStop(1, 'rgba(' + cr + ',' + cg + ',' + cb + ',0)');
        ctx.beginPath();
        ctx.arc(n.x, n.y, midR, 0, Math.PI * 2);
        ctx.fillStyle = g2;
        ctx.fill();
      }

      // Layer 3: Bright core
      if (cR > 0.3) {
        var g3 = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, cR);
        g3.addColorStop(0, 'rgba(255,255,255,' + (ba * 0.85).toFixed(3) + ')');
        g3.addColorStop(0.25, 'rgba(' + cr + ',' + cg + ',' + cb + ',' + (ba * 0.75).toFixed(3) + ')');
        g3.addColorStop(1, 'rgba(' + cr + ',' + cg + ',' + cb + ',0)');
        ctx.beginPath();
        ctx.arc(n.x, n.y, cR, 0, Math.PI * 2);
        ctx.fillStyle = g3;
        ctx.fill();
      }

      // Layer 4: White pip
      if (cR > 1) {
        var pipR = Math.max(0.8, cR * 0.25);
        ctx.beginPath();
        ctx.arc(n.x, n.y, pipR, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,' + (ba * 0.92).toFixed(3) + ')';
        ctx.fill();
      }
    }
  }

  // ────────────────────────────────────────
  // Initial state: single dim center node + ghost ring
  // ────────────────────────────────────────
  function initState() {
    // Center
    nodes[0].x = CX; nodes[0].y = CY;
    nodes[0].tx = CX; nodes[0].ty = CY;
    nodes[0].r = 6; nodes[0].tr = 6;
    nodes[0].halo = 18; nodes[0].thalo = 18;
    nodes[0].alpha = 0.8; nodes[0].talpha = 0.8;

    // Ghost ring (ambient life before answering)
    for (var gi = 1; gi <= 8; gi++) {
      var ga = ((gi - 1) / 8) * Math.PI * 2;
      var gd = 90 + Math.random() * 50;
      nodes[gi].x = CX + Math.cos(ga) * gd;
      nodes[gi].y = CY + Math.sin(ga) * gd;
      nodes[gi].tx = nodes[gi].x;
      nodes[gi].ty = nodes[gi].y;
      nodes[gi].r = 2; nodes[gi].tr = 2;
      nodes[gi].halo = 7; nodes[gi].thalo = 7;
      nodes[gi].alpha = 0.18; nodes[gi].talpha = 0.18;
      nodes[gi].orbitAngle = ga;
      nodes[gi].orbitSpeed = (Math.random() - 0.5) * 0.004;
    }

    // Ghost connections
    connections = [];
    for (var gc = 1; gc <= 8; gc++) {
      connections.push([0, gc]);
    }
    // A couple of ring segments
    connections.push([1, 2]);
    connections.push([3, 4]);
    connections.push([5, 6]);
    connections.push([7, 8]);
  }

  initState();
  frame();
})();
</script>

</body>
</html>
