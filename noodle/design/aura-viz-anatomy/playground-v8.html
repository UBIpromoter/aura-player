<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aura Viz — Multi-Assessment v8</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #030712; color: #e5e7eb;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh;
  }
  .playground {
    display: flex; gap: 36px; padding: 24px 32px;
    max-width: 1120px; margin: 0 auto; align-items: flex-start;
  }

  .q-panel {
    flex: 0 0 330px; position: sticky; top: 20px;
    max-height: calc(100vh - 40px); overflow-y: auto; padding-right: 8px;
  }
  .q-panel::-webkit-scrollbar { width: 4px; }
  .q-panel::-webkit-scrollbar-thumb { background: #374151; border-radius: 2px; }

  .title { font-size: 16px; font-weight: 700; color: #fff; }
  .subtitle { font-size: 11px; color: #6b7280; margin-bottom: 14px; }

  .gate {
    background: linear-gradient(135deg, #1f2937, #111827);
    border: 1px solid #374151; border-radius: 12px;
    padding: 14px; margin-bottom: 14px;
  }
  .gate-label { font-size: 13px; font-weight: 600; color: #d1d5db; margin-bottom: 8px; }
  .gate-tag {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
    color: #f59e0b; background: rgba(245,158,11,0.1);
    padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 700;
  }
  .gate-opts { display: flex; gap: 8px; }
  .gate-btn {
    flex: 1; padding: 10px; border: 2px solid #374151; border-radius: 10px;
    background: transparent; color: #9ca3af; font-size: 13px; font-weight: 500;
    cursor: pointer; transition: all 0.3s; font-family: inherit;
  }
  .gate-btn:hover { border-color: #6b7280; color: #fff; }
  .gate-btn.sel { border-color: #f59e0b; color: #fff; background: rgba(245,158,11,0.1); }

  .neuron-card {
    background: #111827; border: 1px solid #1f2937; border-radius: 10px;
    padding: 12px 14px; margin-bottom: 8px;
  }
  .neuron-hdr {
    display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
  }
  .neuron-dot { width: 10px; height: 10px; border-radius: 50%; transition: all 0.3s; }
  .neuron-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; }
  .neuron-sens {
    font-size: 8px; color: #f59e0b; background: rgba(245,158,11,0.08);
    padding: 1px 5px; border-radius: 3px; margin-left: auto;
  }

  .q-row { margin-bottom: 8px; }
  .q-row:last-child { margin-bottom: 0; }
  .q-type { font-size: 9px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; font-weight: 600; margin-bottom: 3px; }
  .q-text { font-size: 12px; color: #d1d5db; margin-bottom: 5px; font-weight: 500; }
  .q-opts { display: flex; gap: 5px; }
  .q-btn {
    flex: 1; padding: 6px 6px; border: 1px solid #374151; border-radius: 6px;
    background: transparent; color: #9ca3af; font-size: 11px; cursor: pointer;
    transition: all 0.2s; font-family: inherit; line-height: 1.3;
  }
  .q-btn:hover { border-color: #6b7280; color: #fff; }
  .q-btn.sel { border-color: #8b5cf6; color: #fff; background: rgba(139,92,246,0.12); }

  .ctrls { display: flex; gap: 8px; margin-top: 10px; }
  .ctrl {
    flex: 1; padding: 8px; border: 1px solid #374151; border-radius: 7px;
    background: transparent; color: #6b7280; font-size: 11px; cursor: pointer;
    transition: all 0.2s; font-family: inherit; font-weight: 500;
  }
  .ctrl:hover { border-color: #ef4444; color: #ef4444; }
  .ctrl.rand:hover { border-color: #8b5cf6; color: #8b5cf6; }

  .progress { height: 3px; background: #111827; border-radius: 2px; margin-top: 8px; overflow: hidden; }
  .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #8b5cf6, #3b82f6, #10b981); transition: width 0.4s; }

  .viz-panel { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 10px; padding-top: 4px; }
  .entity-tag {
    font-size: 11px; color: #4b5563; padding: 4px 12px;
    border: 1px solid #1f2937; border-radius: 20px; transition: all 0.4s;
  }
  .entity-tag.human { border-color: #10b981; color: #10b981; }
  .entity-tag.ai { border-color: #06b6d4; color: #06b6d4; }
  canvas { border-radius: 14px; display: block; }

  /* Assessment tier toggles */
  .tier-section { margin-top: 12px; }
  .tier-label {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
    color: #6b7280; font-weight: 600; margin-bottom: 6px; padding-left: 2px;
  }
  .tier-grid { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
  .assess-toggle {
    display: flex; align-items: center; gap: 5px;
    padding: 5px 8px; border: 1px solid #1f2937; border-radius: 6px;
    background: transparent; color: #6b7280; font-size: 10px; cursor: pointer;
    transition: all 0.25s; font-family: inherit; white-space: nowrap;
  }
  .assess-toggle:hover { border-color: #374151; color: #9ca3af; }
  .assess-toggle.on { border-color: var(--ac, #6366f1); color: #e5e7eb; background: rgba(99,102,241,0.08); }
  .assess-toggle .dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--ac, #6b7280); opacity: 0.4; transition: opacity 0.2s;
  }
  .assess-toggle.on .dot { opacity: 1; }
  .tier-divider { height: 1px; background: #1f2937; margin: 10px 0; }
  .tier-actions { display: flex; gap: 6px; margin-top: 6px; }
  .tier-btn {
    flex: 1; padding: 6px; border: 1px solid #1f2937; border-radius: 6px;
    background: transparent; color: #4b5563; font-size: 10px; cursor: pointer;
    transition: all 0.2s; font-family: inherit;
  }
  .tier-btn:hover { border-color: #374151; color: #9ca3af; }
</style>
</head>
<body>

<div class="playground">
  <div class="q-panel">
    <div class="title">Shape Your Aura</div>
    <div class="subtitle">Toggle assessments to see the constellation grow.</div>

    <div class="gate">
      <div class="gate-label">Do you have a biological body?<span class="gate-tag">Structure</span></div>
      <div class="gate-opts">
        <button class="gate-btn" id="g0" onclick="setEntity(0)">Yes</button>
        <button class="gate-btn" id="g1" onclick="setEntity(1)">No, I'm an AI</button>
      </div>
    </div>

    <div id="cards"></div>

    <div class="progress"><div class="progress-fill" id="prog"></div></div>
    <div class="ctrls">
      <button class="ctrl rand" onclick="randomize()">Randomize</button>
      <button class="ctrl" onclick="resetAll()">Reset</button>
    </div>

    <div class="tier-divider"></div>

    <div class="tier-section">
      <div class="tier-label">Tier 1 — Starter Pack</div>
      <div class="tier-grid" id="tier1-grid"></div>
    </div>

    <div class="tier-section">
      <div class="tier-label">Tier 2 — Deep Assessments</div>
      <div class="tier-grid" id="tier2-grid"></div>
    </div>

    <div class="tier-actions">
      <button class="tier-btn" onclick="enableAllAssess()">All On</button>
      <button class="tier-btn" onclick="disableAllAssess()">All Off</button>
      <button class="tier-btn" onclick="randomAssess()">Random Mix</button>
    </div>
  </div>

  <div class="viz-panel">
    <div class="entity-tag" id="etag">Unanswered</div>
    <canvas id="aura" width="600" height="600"></canvas>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════
// PALETTE
// ═══════════════════════════════════════════════════════
const C = {
  violet:'#8b5cf6', blue:'#3b82f6', teal:'#14b8a6', rose:'#f43f5e',
  pink:'#d946ef', emerald:'#10b981', amber:'#f59e0b', indigo:'#6366f1', cyan:'#06b6d4',
};
function hexRgb(hex) {
  const n = parseInt(hex.slice(1), 16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

// ═══════════════════════════════════════════════════════
// 5 NEURONS — each has a color Q and a position Q
// ═══════════════════════════════════════════════════════
const NEURONS = [
  {
    name: 'Neuron 1',
    colorQ: { text: "Which came first?", opts: ["The chicken","The egg"], colors: [C.violet, C.blue] },
    posQ:   { text: "Better pizza topping:", opts: ["Pepperoni","Pineapple"], sensitive: true, why: "You don't eat" },
    // Human: organic cluster (positions closer, natural). AI: geometric spread (symmetric, angular)
    humanPos: [{ x:150, y:140 }, { x:270, y:120 }],
    aiPos:    [{ x:270, y:90 }, { x:270, y:180 }],  // vertical axis
  },
  {
    name: 'Neuron 2',
    colorQ: { text: "Is a hot dog a sandwich?", opts: ["Yes, obviously","No way"], colors: [C.indigo, C.rose] },
    posQ:   { text: "Coffee in the morning?", opts: ["Yes please","Not for me"], sensitive: true, why: "You don't drink" },
    humanPos: [{ x:350, y:170 }, { x:380, y:300 }],
    aiPos:    [{ x:400, y:220 }, { x:380, y:340 }],  // right side
  },
  {
    name: 'Neuron 3',
    colorQ: { text: "Better superpower:", opts: ["Flight","Invisibility"], colors: [C.pink, C.teal] },
    posQ:   { text: "In 10 years, driving will be...", opts: ["Still manual","Self-driving"] },
    humanPos: [{ x:240, y:250 }, { x:290, y:320 }],
    aiPos:    [{ x:320, y:410 }, { x:220, y:410 }],  // bottom symmetric
  },
  {
    name: 'Neuron 4',
    colorQ: { text: "Will AI replace most jobs?", opts: ["Yes, big changes","No, jobs adapt"], colors: [C.emerald, C.amber], sensitive: true, why: "About yourself" },
    posQ:   { text: "Dogs or cats?", opts: ["Dogs","Cats"], sensitive: true, why: "Different relationship" },
    humanPos: [{ x:140, y:340 }, { x:220, y:410 }],
    aiPos:    [{ x:140, y:340 }, { x:160, y:220 }],  // left side
  },
  {
    name: 'Neuron 5',
    colorQ: { text: "Will humans live on Mars by 2050?", opts: ["Yes","No"], colors: [C.cyan, C.violet], sensitive: true, why: "Different stakes" },
    posQ:   { text: "Is water wet?", opts: ["Yes","No"] },
    humanPos: [{ x:340, y:380 }, { x:400, y:430 }],
    aiPos:    [{ x:270, y:290 }, { x:270, y:260 }],  // center
  },
];

// Connections
const HUMAN_CONNS = [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,3],[1,4]];
const AI_CONNS = [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,4],[1,3],[0,3],[1,4]];

// ═══════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════
const colorAns = new Array(5).fill(null);
const posAns = new Array(5).fill(null);
let entity = null;

function setEntity(v) {
  entity = v;
  document.getElementById('g0').classList.toggle('sel', v===0);
  document.getElementById('g1').classList.toggle('sel', v===1);
  const et = document.getElementById('etag');
  if (v===0) { et.textContent='Biological'; et.className='entity-tag human'; }
  else { et.textContent='Artificial Intelligence'; et.className='entity-tag ai'; }
  // Flash all nodes on entity change
  if (typeof allNodes !== 'undefined') {
    for (let i=0;i<allNodes.length;i++) if (allNodes[i].alpha > 0.05) allNodes[i].flash = 0.6;
  }
  buildUI(); updateProg();
}

function pickColor(ni, v) {
  const changed = colorAns[ni] !== v;
  colorAns[ni] = v;
  if (typeof allNodes !== 'undefined' && changed) {
    allNodes[ni].flash = 1.0;
    if (allNodes[5+ni*2]) allNodes[5+ni*2].flash = 0.6;
    if (allNodes[5+ni*2+1]) allNodes[5+ni*2+1].flash = 0.5;
  }
  buildUI(); updateProg();
}

function pickPos(ni, v) {
  const changed = posAns[ni] !== v;
  posAns[ni] = v;
  if (typeof allNodes !== 'undefined' && changed) {
    allNodes[ni].flash = 0.8;
    if (allNodes[5+ni*2]) allNodes[5+ni*2].flash = 0.5;
    if (allNodes[5+ni*2+1]) allNodes[5+ni*2+1].flash = 0.4;
  }
  buildUI(); updateProg();
}

function resetAll() {
  colorAns.fill(null); posAns.fill(null); entity = null;
  document.getElementById('g0').classList.remove('sel');
  document.getElementById('g1').classList.remove('sel');
  document.getElementById('etag').textContent = 'Unanswered';
  document.getElementById('etag').className = 'entity-tag';
  buildUI(); updateProg();
}

function randomize() {
  for (let i=0;i<5;i++) { colorAns[i]=Math.random()<0.5?0:1; posAns[i]=Math.random()<0.5?0:1; }
  setEntity(Math.random()<0.85?0:1);
}

function updateProg() {
  const c = colorAns.filter(a=>a!==null).length + posAns.filter(a=>a!==null).length + (entity!==null?1:0);
  document.getElementById('prog').style.width = (c/11*100)+'%';
}

function buildUI() {
  const el = document.getElementById('cards');
  el.innerHTML = '';
  NEURONS.forEach((n, i) => {
    const color = colorAns[i] !== null ? n.colorQ.colors[colorAns[i]] : '#4b5563';
    const hasSensitive = n.colorQ.sensitive || n.posQ.sensitive;
    const card = document.createElement('div');
    card.className = 'neuron-card';
    card.innerHTML = `
      <div class="neuron-hdr">
        <div class="neuron-dot" style="background:${color};box-shadow:0 0 8px ${color}"></div>
        <span class="neuron-name">${n.name}</span>
        ${hasSensitive && entity===1 ? '<span class="neuron-sens">entity-sensitive</span>' : ''}
      </div>
      <div class="q-row">
        <div class="q-type">Color${n.colorQ.sensitive && entity===1 ? ' · '+n.colorQ.why : ''}</div>
        <div class="q-text">${n.colorQ.text}</div>
        <div class="q-opts">
          <button class="q-btn${colorAns[i]===0?' sel':''}" onclick="pickColor(${i},0)">${n.colorQ.opts[0]}</button>
          <button class="q-btn${colorAns[i]===1?' sel':''}" onclick="pickColor(${i},1)">${n.colorQ.opts[1]}</button>
        </div>
      </div>
      <div class="q-row">
        <div class="q-type">Position${n.posQ.sensitive && entity===1 ? ' · '+n.posQ.why : ''}</div>
        <div class="q-text">${n.posQ.text}</div>
        <div class="q-opts">
          <button class="q-btn${posAns[i]===0?' sel':''}" onclick="pickPos(${i},0)">${n.posQ.opts[0]}</button>
          <button class="q-btn${posAns[i]===1?' sel':''}" onclick="pickPos(${i},1)">${n.posQ.opts[1]}</button>
        </div>
      </div>`;
    el.appendChild(card);
  });
}

buildUI();

// ═══════════════════════════════════════════════════════
// CANVAS — Constellation Marriage
// ═══════════════════════════════════════════════════════
const canvas = document.getElementById('aura');
const ctx = canvas.getContext('2d');
const W = 600, H = 600, CX = 300, CY = 300;

function lerp(a,b,t) { return a+(b-a)*t; }
function lerpRgb(a,b,t) { return [lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)]; }
function rgbStr(c,a) { return `rgba(${c[0]|0},${c[1]|0},${c[2]|0},${a.toFixed(3)})`; }

// ═══════════════════════════════════════════════════════
// ASSESSMENT MODEL
// ═══════════════════════════════════════════════════════
const ASSESSMENTS = [
  { id: 'starter-personality', name: 'Personality', color: C.violet, tier: 1, nodes: 3 },
  { id: 'starter-motivation', name: 'Motivation', color: C.amber, tier: 1, nodes: 3 },
  { id: 'starter-thinking', name: 'Thinking', color: C.blue, tier: 1, nodes: 3 },
  { id: 'starter-connection', name: 'Connection', color: C.pink, tier: 1, nodes: 3 },
  { id: 'starter-strategy', name: 'Strategy', color: C.emerald, tier: 1, nodes: 3 },
  { id: 'bigfive', name: 'Big Five', color: C.violet, tier: 2, nodes: 5 },
  { id: 'character', name: 'Character', color: C.emerald, tier: 2, nodes: 3 },
  { id: 'shadow', name: 'Shadow Self', color: C.indigo, tier: 2, nodes: 4 },
  { id: 'mind', name: 'Mind', color: C.cyan, tier: 2, nodes: 4 },
  { id: 'relationships', name: 'Relationships', color: C.rose, tier: 2, nodes: 3 },
  { id: 'behavior', name: 'Behavior', color: C.amber, tier: 2, nodes: 3 },
];

const assessState = {};
ASSESSMENTS.forEach(a => assessState[a.id] = false);

function toggleAssess(id) {
  assessState[id] = !assessState[id];
  rebuildAllNodes();
  buildAssessUI();
}
function enableAllAssess() {
  ASSESSMENTS.forEach(a => assessState[a.id] = true);
  rebuildAllNodes(); buildAssessUI();
}
function disableAllAssess() {
  ASSESSMENTS.forEach(a => assessState[a.id] = false);
  rebuildAllNodes(); buildAssessUI();
}
function randomAssess() {
  ASSESSMENTS.forEach(a => assessState[a.id] = Math.random() < 0.5);
  rebuildAllNodes(); buildAssessUI();
}

function buildAssessUI() {
  ['tier1-grid','tier2-grid'].forEach(gid => {
    const el = document.getElementById(gid);
    const tier = gid === 'tier1-grid' ? 1 : 2;
    el.innerHTML = '';
    ASSESSMENTS.filter(a => a.tier === tier).forEach(a => {
      const btn = document.createElement('button');
      btn.className = 'assess-toggle' + (assessState[a.id] ? ' on' : '');
      btn.style.setProperty('--ac', a.color);
      btn.innerHTML = `<span class="dot"></span>${a.name}`;
      btn.onclick = () => toggleAssess(a.id);
      el.appendChild(btn);
    });
  });
}
buildAssessUI();

// ═══════════════════════════════════════════════════════
// DYNAMIC NODE SYSTEM
// ═══════════════════════════════════════════════════════
const allNodes = [];

function makeNode(opts) {
  return {
    x: opts.x || CX, y: opts.y || CY,
    tx: opts.x || CX, ty: opts.y || CY,
    color: opts.color ? hexRgb(opts.color) : [70,75,90],
    tcolor: opts.color ? hexRgb(opts.color) : [70,75,90],
    r: opts.r || 2, tr: opts.r || 2,
    halo: opts.halo || 8, thalo: opts.halo || 8,
    alpha: 0, talpha: 0,
    phase: Math.random() * Math.PI * 2,
    orbitAngle: Math.random() * Math.PI * 2,
    orbitSpeed: (Math.random() - 0.5) * 0.005,
    driftSpeed: 0.4 + Math.random() * 0.5,
    driftAmp: 3 + Math.random() * 4,
    phaseX: Math.random() * 6, phaseY: Math.random() * 6,
    flash: 0,
    type: opts.type || 'primary',
    parent: opts.parent ?? -1,
    sensitive: opts.sensitive || false,
    assessId: opts.assessId || null,
    tier: opts.tier || 0,
  };
}

// Seeded random for deterministic assessment positions
function seededRng(seed) {
  let s = seed;
  return () => { s = (s * 16807 + 0) % 2147483647; return s / 2147483647; };
}

// Rebuild entire node pool based on current state
function rebuildAllNodes() {
  // Keep existing primaries + companions + satellites (first 20) or build them
  while (allNodes.length < 20) allNodes.push(makeNode({}));

  // Init 5 primaries
  for (let i = 0; i < 5; i++) {
    const mid = { x: (NEURONS[i].humanPos[0].x + NEURONS[i].humanPos[1].x)/2 + 30,
                  y: (NEURONS[i].humanPos[0].y + NEURONS[i].humanPos[1].y)/2 + 30 };
    const isSens = NEURONS[i].colorQ.sensitive || NEURONS[i].posQ.sensitive;
    Object.assign(allNodes[i], { tx: mid.x, ty: mid.y, tr: 5, thalo: 22, type: 'primary', sensitive: isSens, tier: 0 });
    if (allNodes[i].x === CX && allNodes[i].y === CY) { allNodes[i].x = mid.x; allNodes[i].y = mid.y; }
  }

  // 10 companions (idx 5-14)
  for (let i = 0; i < 5; i++) {
    for (let c = 0; c < 2; c++) {
      const idx = 5 + i*2 + c;
      Object.assign(allNodes[idx], { type: 'companion', parent: i, tr: 2.5, thalo: 10, tier: 0 });
    }
  }

  // 5 satellites (idx 15-19)
  for (let s = 0; s < 5; s++) {
    Object.assign(allNodes[15+s], { type: 'satellite', parent: s, tr: 2, thalo: 7, tier: 0 });
  }

  // Remove old assessment nodes (idx 20+)
  allNodes.length = 20;

  // Add nodes for each enabled assessment
  let assessIdx = 0;
  ASSESSMENTS.forEach((assess, ai) => {
    if (!assessState[assess.id]) return;
    const rng = seededRng(ai * 137 + 42);
    const ringDist = assess.tier === 1 ? 140 : 210;
    const baseAngle = (assessIdx / Math.max(1, Object.values(assessState).filter(v=>v).length)) * Math.PI * 2;

    for (let ni = 0; ni < assess.nodes; ni++) {
      const angle = baseAngle + (ni / assess.nodes) * 0.6 - 0.3;
      const dist = ringDist + (rng() - 0.5) * 40;
      const x = CX + Math.cos(angle) * dist;
      const y = CY + Math.sin(angle) * dist;
      allNodes.push(makeNode({
        x, y, r: 2 + rng() * 2, halo: 8 + rng() * 10,
        type: 'assess', color: assess.color,
        assessId: assess.id, tier: assess.tier,
        parent: Math.floor(rng() * 5),  // connect to random primary
      }));
    }
    assessIdx++;
  });

  // Flash new nodes
  for (let i = 20; i < allNodes.length; i++) allNodes[i].flash = 0.5;
}

rebuildAllNodes();

// Connection topology
let activeConns = [];

function buildConnections() {
  const conns = [];
  const isAI = entity === 1;
  const answeredCount = colorAns.filter(a=>a!==null).length + posAns.filter(a=>a!==null).length;
  const N = allNodes.length;

  // Primary-to-primary
  const primConns = isAI
    ? [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,4],[1,3],[0,3],[1,4]]
    : [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,3],[1,4]];
  for (const [a,b] of primConns) {
    if (allNodes[a].alpha > 0.2 && allNodes[b].alpha > 0.2) conns.push([a,b]);
  }

  // Primary-to-companion
  for (let ci = 5; ci < 15; ci++) {
    const p = allNodes[ci].parent;
    if (allNodes[ci].alpha > 0.05 && allNodes[p].alpha > 0.2) conns.push([p, ci]);
  }

  // Companion-to-companion (same parent)
  for (let i = 0; i < 5; i++) {
    const c1 = 5+i*2, c2 = 5+i*2+1;
    if (allNodes[c1].alpha > 0.05 && allNodes[c2].alpha > 0.05) conns.push([c1, c2]);
  }

  // Cross-companion bridges
  if (answeredCount >= 4) {
    for (let i = 0; i < 4; i++) {
      const c1 = 5+i*2+1, c2 = 5+(i+1)*2;
      if (allNodes[c1].alpha > 0.05 && allNodes[c2].alpha > 0.05) conns.push([c1, c2]);
    }
  }

  // Satellite connections
  for (let si = 15; si < 20; si++) {
    const p = allNodes[si].parent;
    if (allNodes[si].alpha > 0.05 && allNodes[p].alpha > 0.2) conns.push([p, si]);
  }
  if (answeredCount >= 8) {
    for (let si = 0; si < 5; si++) {
      const next = (si+1) % 5;
      if (allNodes[15+si].alpha > 0.05 && allNodes[15+next].alpha > 0.05) conns.push([15+si, 15+next]);
    }
  }

  // Assessment node connections — to parent primary + to nearest assessment neighbors
  for (let ai = 20; ai < N; ai++) {
    const an = allNodes[ai];
    if (an.alpha < 0.03) continue;

    // Connect to parent primary
    if (an.parent >= 0 && allNodes[an.parent].alpha > 0.2) {
      conns.push([an.parent, ai]);
    }

    // Connect to nearest other assessment node of same assessment
    for (let aj = 20; aj < N; aj++) {
      if (ai === aj) continue;
      if (allNodes[aj].assessId === an.assessId && allNodes[aj].alpha > 0.03) {
        conns.push([ai, aj]);
      }
    }

    // Connect to nearest satellite or companion (bridge to inner)
    let bestDist = Infinity, bestIdx = -1;
    for (let bi = 5; bi < 20; bi++) {
      if (allNodes[bi].alpha < 0.03) continue;
      const dx = an.x - allNodes[bi].x, dy = an.y - allNodes[bi].y;
      const d = dx*dx + dy*dy;
      if (d < bestDist) { bestDist = d; bestIdx = bi; }
    }
    if (bestIdx >= 0 && bestDist < 200*200) conns.push([ai, bestIdx]);
  }

  activeConns = conns;
}

// Stars
const stars = [];
for (let i = 0; i < 100; i++) stars.push({
  x: Math.random()*W, y: Math.random()*H,
  r: 0.2 + Math.random() * 0.9,
  bright: Math.random() * 0.35 + 0.05,
  phase: Math.random() * Math.PI * 2,
  speed: 0.5 + Math.random() * 2.5
});

// ═══════════════════════════════════════════════════════
// TARGET COMPUTATION
// ═══════════════════════════════════════════════════════
function computeTargets() {
  const isAI = entity === 1;
  const answeredCount = colorAns.filter(a=>a!==null).length + posAns.filter(a=>a!==null).length;

  // Primary nodes (offset +30 to center in larger canvas)
  for (let i = 0; i < 5; i++) {
    const n = NEURONS[i];
    const posSet = isAI ? n.aiPos : n.humanPos;
    const node = allNodes[i];

    if (posAns[i] !== null) {
      node.tx = posSet[posAns[i]].x + 30;
      node.ty = posSet[posAns[i]].y + 30;
    } else {
      node.tx = (posSet[0].x + posSet[1].x) / 2 + 30;
      node.ty = (posSet[0].y + posSet[1].y) / 2 + 30;
    }

    if (colorAns[i] !== null) {
      node.tcolor = hexRgb(n.colorQ.colors[colorAns[i]]);
      node.tr = 6; node.thalo = 28; node.talpha = 1;
    } else {
      node.tcolor = [70,75,90]; node.tr = 3; node.thalo = 10; node.talpha = 0.18;
    }
    if (posAns[i] !== null && colorAns[i] === null) {
      node.talpha = 0.45; node.tr = 4; node.thalo = 16;
    }
  }

  // Companion nodes
  for (let ci = 0; ci < 10; ci++) {
    const node = allNodes[5+ci];
    const pi = node.parent;
    const parent = allNodes[pi];
    const answered = colorAns[pi] !== null || posAns[pi] !== null;
    if (answered) {
      const angle = node.orbitAngle + time * 0.0008;
      const dist = 22 + (ci % 2) * 18;
      node.tx = parent.tx + Math.cos(angle) * dist;
      node.ty = parent.ty + Math.sin(angle) * dist;
      node.tcolor = parent.tcolor; node.tr = 2 + (ci%2)*1.2;
      node.thalo = 8 + (ci%2)*4; node.talpha = parent.talpha * 0.6;
    } else { node.tx = parent.tx; node.ty = parent.ty; node.talpha = 0; }
  }

  // Satellite nodes
  for (let si = 0; si < 5; si++) {
    const node = allNodes[15+si];
    const parent = allNodes[node.parent];
    if (answeredCount >= 6 && parent.talpha > 0.3) {
      const baseAngle = (si/5)*Math.PI*2 + Math.PI/10;
      const angle = baseAngle + Math.sin(time*0.15+si*1.2) * (isAI?0.05:0.15);
      const dist = (isAI ? 195 : 180 + Math.sin(time*0.1+si)*15) + 20;
      node.tx = CX + Math.cos(angle)*dist;
      node.ty = CY + Math.sin(angle)*dist;
      node.tcolor = parent.tcolor; node.tr = 2; node.thalo = 7;
      node.talpha = 0.5 * Math.min(1, (answeredCount-5)/4);
    } else { node.talpha = 0; }
  }

  // Assessment nodes — already positioned, just set alpha
  for (let ai = 20; ai < allNodes.length; ai++) {
    const node = allNodes[ai];
    if (assessState[node.assessId]) {
      node.talpha = 0.85;
      // Gently orbit around initial position
      const baseX = node.tx, baseY = node.ty;
    } else {
      node.talpha = 0;
    }
  }

  buildConnections();
}

// ═══════════════════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════════════════
let lastTime = performance.now();
let time = 0;

function frame(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  time = now / 1000;

  computeTargets();

  const isAI = entity === 1;
  const spd = 4 * dt;    // smoother, more fluid than before
  const cspd = 6 * dt;

  for (let i = 0; i < allNodes.length; i++) {
    const n = allNodes[i];
    n.x = lerp(n.x, n.tx, spd);
    n.y = lerp(n.y, n.ty, spd);
    n.r = lerp(n.r, n.tr + n.flash * 5, spd);
    n.halo = lerp(n.halo, n.thalo + n.flash * 20, spd);
    n.alpha = lerp(n.alpha, n.talpha + n.flash * 0.3, spd * 0.7);
    n.color = lerpRgb(n.color, n.tcolor, cspd);

    const driftMult = isAI ? 0.3 : 1.0;
    n.orbitAngle += n.orbitSpeed * driftMult;

    n.flash *= 0.91;
    if (n.flash < 0.01) n.flash = 0;
  }

  render();
  requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════
// SHAPE HELPERS
// ═══════════════════════════════════════════════════════
function diamond(cx, cy, s) {
  ctx.beginPath();
  ctx.moveTo(cx, cy - s);
  ctx.lineTo(cx + s, cy);
  ctx.lineTo(cx, cy + s);
  ctx.lineTo(cx - s, cy);
  ctx.closePath();
}

function triangle(cx, cy, s) {
  const h = s * 1.15;
  ctx.beginPath();
  ctx.moveTo(cx, cy - h);
  ctx.lineTo(cx + s, cy + h * 0.5);
  ctx.lineTo(cx - s, cy + h * 0.5);
  ctx.closePath();
}

// Animated position with multi-harmonic drift
function animPos(n) {
  const isAI = entity === 1;
  const t = time;
  const sp = n.driftSpeed;
  const amp = n.driftAmp * (isAI ? 0.3 : 1.0);
  // Multi-harmonic
  const dx = Math.sin(t * sp + n.phaseX) * amp
           + Math.sin(t * sp * 0.4 + n.phaseX * 2.1) * amp * 0.5;
  const dy = Math.cos(t * sp * 0.75 + n.phaseY) * amp
           + Math.cos(t * sp * 0.35 + n.phaseY * 1.7) * amp * 0.4;
  // Orbital wobble
  const wobble = isAI ? 1 : 3;
  const ox = Math.cos(n.orbitAngle * 0.7 + t * 0.15) * wobble;
  const oy = Math.sin(n.orbitAngle * 0.9 + t * 0.12) * wobble;
  return { x: n.x + dx + ox, y: n.y + dy + oy };
}

// ═══════════════════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════════════════
function render() {
  const isAI = entity === 1;
  const breath = 1 + 0.06 * Math.sin(time * 0.4);

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#030712';
  ctx.fillRect(0, 0, W, H);

  // ── STARS ──
  for (const s of stars) {
    const tw = s.bright * (0.5 + 0.5 * Math.sin(time * s.speed + s.phase));
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fillStyle = rgbStr([180,200,255], tw); ctx.fill();
  }

  // ── AI HEX GRID ──
  if (isAI) {
    ctx.save(); ctx.globalAlpha = 0.025;
    ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 0.5;
    for (let ring = 1; ring <= 4; ring++) {
      ctx.beginPath();
      for (let i = 0; i <= 6; i++) {
        const a = (i/6)*Math.PI*2 - Math.PI/6;
        const r = ring * 55;
        const px = CX + Math.cos(a)*r, py = CY + Math.sin(a)*r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  // ── NEBULA GLOW (multi-color clouds — primaries + assessment clusters) ──
  // Primaries get big nebula, assessment nodes get smaller ones
  for (let i = 0; i < allNodes.length; i++) {
    const n = allNodes[i];
    if (n.alpha < 0.1) continue;
    if (n.type !== 'primary' && n.type !== 'assess') continue;
    const p = animPos(n);
    const c = n.color;

    let nebulaR = n.type === 'primary' ? (n.halo * 3 + 30) * breath : (n.halo * 2 + 15) * breath;
    if (isAI) nebulaR *= 0.65;
    const na = n.alpha * (isAI ? 0.09 : 0.14) * (n.type === 'assess' ? 0.7 : 1);

    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, nebulaR);
    g.addColorStop(0, rgbStr(c, na));
    g.addColorStop(0.35, rgbStr(c, na * 0.45));
    g.addColorStop(0.7, rgbStr(c, na * 0.1));
    g.addColorStop(1, rgbStr(c, 0));
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(p.x, p.y, nebulaR, 0, Math.PI*2); ctx.fill();
  }

  // ── CONNECTIONS (double-line: glow + crisp) ──
  for (const [a, b] of activeConns) {
    const na = allNodes[a], nb = allNodes[b];
    if (na.alpha < 0.03 || nb.alpha < 0.03) continue;

    const pa = animPos(na), pb = animPos(nb);
    const dx = pa.x - pb.x, dy = pa.y - pb.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const distFade = Math.max(0, 1 - dist / 500);
    const minA = Math.min(na.alpha, nb.alpha);
    const alpha = distFade * minA * 0.45;
    if (alpha < 0.005) continue;

    const mc = lerpRgb(na.color, nb.color, 0.5);

    if (isAI) {
      // Straight — glow
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y);
      ctx.strokeStyle = rgbStr(mc, alpha * 0.35);
      ctx.lineWidth = 3; ctx.stroke();
      // Crisp core
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y);
      ctx.strokeStyle = rgbStr(mc, alpha);
      ctx.lineWidth = 0.7; ctx.stroke();
    } else {
      // Curved — glow
      const mx = (pa.x+pb.x)/2 + Math.sin(time*0.2 + a + b) * 10;
      const my = (pa.y+pb.y)/2 + Math.cos(time*0.15 + a*0.7) * 10;
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y); ctx.quadraticCurveTo(mx, my, pb.x, pb.y);
      ctx.strokeStyle = rgbStr(mc, alpha * 0.3);
      ctx.lineWidth = 3; ctx.stroke();
      // Crisp core
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y); ctx.quadraticCurveTo(mx, my, pb.x, pb.y);
      ctx.strokeStyle = rgbStr(mc, alpha);
      ctx.lineWidth = 0.7; ctx.stroke();
    }
  }

  // ── NODE GLOW (per-node halo — 3-layer radial gradient) ──
  // Sort: low alpha first
  const order = [];
  for (let i = 0; i < allNodes.length; i++) order.push(i);
  order.sort((a,b) => allNodes[a].alpha - allNodes[b].alpha);

  for (const idx of order) {
    const n = allNodes[idx];
    if (n.alpha < 0.02) continue;

    const p = animPos(n);
    const c = n.color;
    const ba = n.alpha;
    const hR = (n.halo + n.flash * 15) * breath;
    const cR = (n.r + n.flash * 3) * breath;

    // Layer 1: Outer halo
    if (hR > 2) {
      const g1 = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, hR);
      g1.addColorStop(0, rgbStr(c, ba * 0.12));
      g1.addColorStop(0.45, rgbStr(c, ba * 0.05));
      g1.addColorStop(1, rgbStr(c, 0));

      if (isAI && n.type === 'primary') {
        const isSens = n.sensitive;
        ctx.save();
        if (isSens) triangle(p.x, p.y, hR * 1.3);
        else diamond(p.x, p.y, hR * 1.3);
        ctx.clip();
        ctx.fillStyle = g1;
        ctx.fillRect(p.x - hR, p.y - hR, hR * 2, hR * 2);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, hR, 0, Math.PI*2);
        ctx.fillStyle = g1; ctx.fill();
      }
    }

    // Layer 2: Mid glow
    if (cR > 0.5) {
      const midR = cR * 2.8;
      const g2 = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, midR);
      g2.addColorStop(0, rgbStr(c, ba * 0.45));
      g2.addColorStop(0.5, rgbStr(c, ba * 0.12));
      g2.addColorStop(1, rgbStr(c, 0));
      ctx.beginPath(); ctx.arc(p.x, p.y, midR, 0, Math.PI*2);
      ctx.fillStyle = g2; ctx.fill();
    }

    // Layer 3: Bright core
    if (cR > 0.3) {
      const g3 = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, cR);
      g3.addColorStop(0, rgbStr([255,255,255], ba * 0.85));
      g3.addColorStop(0.25, rgbStr(c, ba * 0.75));
      g3.addColorStop(1, rgbStr(c, 0));

      if (isAI && n.type === 'primary') {
        const isSens = n.sensitive;
        if (isSens) { triangle(p.x, p.y, cR); }
        else { diamond(p.x, p.y, cR); }
        ctx.fillStyle = g3;
        // Can't use radial gradient in non-arc, so fill solid
        ctx.fillStyle = rgbStr(c, ba * 0.9);
        ctx.fill();
        // White pip as shape
        if (isSens) triangle(p.x, p.y, cR * 0.25);
        else diamond(p.x, p.y, cR * 0.25);
        ctx.fillStyle = rgbStr([255,255,255], ba * 0.8);
        ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, cR, 0, Math.PI*2);
        ctx.fillStyle = g3; ctx.fill();
      }
    }

    // Layer 4: White pip (circles / companions / satellites)
    if (cR > 1 && !(isAI && n.type === 'primary')) {
      const pipR = Math.max(0.6, cR * 0.25);
      ctx.beginPath(); ctx.arc(p.x, p.y, pipR, 0, Math.PI*2);
      ctx.fillStyle = rgbStr([255,255,255], ba * 0.9);
      ctx.fill();
    }

    // Flash ring
    if (n.flash > 0.05) {
      const flashR = cR * (3 + (1 - n.flash) * 8);
      if (isAI && n.type === 'primary' && n.sensitive) {
        triangle(p.x, p.y, flashR);
      } else if (isAI && n.type === 'primary') {
        diamond(p.x, p.y, flashR);
      } else {
        ctx.beginPath(); ctx.arc(p.x, p.y, flashR, 0, Math.PI*2);
      }
      ctx.strokeStyle = rgbStr(c, n.flash * 0.4);
      ctx.lineWidth = 2 * n.flash; ctx.stroke();
    }
  }
}

requestAnimationFrame(frame);
</script>
</body>
</html>
