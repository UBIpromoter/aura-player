<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aura Viz — 5 Neurons, 10 Answers v4</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #030712; color: #e5e7eb;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh;
  }
  .playground {
    display: flex; gap: 36px; padding: 24px 32px;
    max-width: 1120px; margin: 0 auto; align-items: flex-start;
  }

  .q-panel {
    flex: 0 0 330px; position: sticky; top: 20px;
    max-height: calc(100vh - 40px); overflow-y: auto; padding-right: 8px;
  }
  .q-panel::-webkit-scrollbar { width: 4px; }
  .q-panel::-webkit-scrollbar-thumb { background: #374151; border-radius: 2px; }

  .title { font-size: 16px; font-weight: 700; color: #fff; }
  .subtitle { font-size: 11px; color: #6b7280; margin-bottom: 14px; }

  .gate {
    background: linear-gradient(135deg, #1f2937, #111827);
    border: 1px solid #374151; border-radius: 12px;
    padding: 14px; margin-bottom: 14px;
  }
  .gate-label { font-size: 13px; font-weight: 600; color: #d1d5db; margin-bottom: 8px; }
  .gate-tag {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
    color: #f59e0b; background: rgba(245,158,11,0.1);
    padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 700;
  }
  .gate-opts { display: flex; gap: 8px; }
  .gate-btn {
    flex: 1; padding: 10px; border: 2px solid #374151; border-radius: 10px;
    background: transparent; color: #9ca3af; font-size: 13px; font-weight: 500;
    cursor: pointer; transition: all 0.3s; font-family: inherit;
  }
  .gate-btn:hover { border-color: #6b7280; color: #fff; }
  .gate-btn.sel { border-color: #f59e0b; color: #fff; background: rgba(245,158,11,0.1); }

  .neuron-card {
    background: #111827; border: 1px solid #1f2937; border-radius: 10px;
    padding: 12px 14px; margin-bottom: 8px;
  }
  .neuron-hdr {
    display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
  }
  .neuron-dot { width: 10px; height: 10px; border-radius: 50%; transition: all 0.3s; }
  .neuron-name { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; }
  .neuron-sens {
    font-size: 8px; color: #f59e0b; background: rgba(245,158,11,0.08);
    padding: 1px 5px; border-radius: 3px; margin-left: auto;
  }

  .q-row { margin-bottom: 8px; }
  .q-row:last-child { margin-bottom: 0; }
  .q-type { font-size: 9px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; font-weight: 600; margin-bottom: 3px; }
  .q-text { font-size: 12px; color: #d1d5db; margin-bottom: 5px; font-weight: 500; }
  .q-opts { display: flex; gap: 5px; }
  .q-btn {
    flex: 1; padding: 6px 6px; border: 1px solid #374151; border-radius: 6px;
    background: transparent; color: #9ca3af; font-size: 11px; cursor: pointer;
    transition: all 0.2s; font-family: inherit; line-height: 1.3;
  }
  .q-btn:hover { border-color: #6b7280; color: #fff; }
  .q-btn.sel { border-color: #8b5cf6; color: #fff; background: rgba(139,92,246,0.12); }

  .ctrls { display: flex; gap: 8px; margin-top: 10px; }
  .ctrl {
    flex: 1; padding: 8px; border: 1px solid #374151; border-radius: 7px;
    background: transparent; color: #6b7280; font-size: 11px; cursor: pointer;
    transition: all 0.2s; font-family: inherit; font-weight: 500;
  }
  .ctrl:hover { border-color: #ef4444; color: #ef4444; }
  .ctrl.rand:hover { border-color: #8b5cf6; color: #8b5cf6; }

  .progress { height: 3px; background: #111827; border-radius: 2px; margin-top: 8px; overflow: hidden; }
  .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #8b5cf6, #3b82f6, #10b981); transition: width 0.4s; }

  .viz-panel { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 10px; padding-top: 4px; }
  .entity-tag {
    font-size: 11px; color: #4b5563; padding: 4px 12px;
    border: 1px solid #1f2937; border-radius: 20px; transition: all 0.4s;
  }
  .entity-tag.human { border-color: #10b981; color: #10b981; }
  .entity-tag.ai { border-color: #06b6d4; color: #06b6d4; }
  canvas { border-radius: 14px; display: block; }
</style>
</head>
<body>

<div class="playground">
  <div class="q-panel">
    <div class="title">Shape Your Aura</div>
    <div class="subtitle">5 neurons. Color + position. Every click changes something.</div>

    <div class="gate">
      <div class="gate-label">Do you have a biological body?<span class="gate-tag">Structure</span></div>
      <div class="gate-opts">
        <button class="gate-btn" id="g0" onclick="setEntity(0)">Yes</button>
        <button class="gate-btn" id="g1" onclick="setEntity(1)">No, I'm an AI</button>
      </div>
    </div>

    <div id="cards"></div>

    <div class="progress"><div class="progress-fill" id="prog"></div></div>
    <div class="ctrls">
      <button class="ctrl rand" onclick="randomize()">Randomize</button>
      <button class="ctrl" onclick="resetAll()">Reset</button>
    </div>
  </div>

  <div class="viz-panel">
    <div class="entity-tag" id="etag">Unanswered</div>
    <canvas id="aura" width="540" height="540"></canvas>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════
// PALETTE
// ═══════════════════════════════════════════════════════
const C = {
  violet:'#8b5cf6', blue:'#3b82f6', teal:'#14b8a6', rose:'#f43f5e',
  pink:'#d946ef', emerald:'#10b981', amber:'#f59e0b', indigo:'#6366f1', cyan:'#06b6d4',
};
function hexRgb(hex) {
  const n = parseInt(hex.slice(1), 16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

// ═══════════════════════════════════════════════════════
// 5 NEURONS — each has a color Q and a position Q
// ═══════════════════════════════════════════════════════
const NEURONS = [
  {
    name: 'Neuron 1',
    colorQ: { text: "Which came first?", opts: ["The chicken","The egg"], colors: [C.violet, C.blue] },
    posQ:   { text: "Better pizza topping:", opts: ["Pepperoni","Pineapple"], sensitive: true, why: "You don't eat" },
    // Position A / B for human, A / B for AI (spread far apart so move is obvious)
    humanPos: [{ x:170, y:160 }, { x:280, y:140 }],
    aiPos:    [{ x:150, y:130 }, { x:270, y:100 }],
  },
  {
    name: 'Neuron 2',
    colorQ: { text: "Is a hot dog a sandwich?", opts: ["Yes, obviously","No way"], colors: [C.indigo, C.rose] },
    posQ:   { text: "Coffee in the morning?", opts: ["Yes please","Not for me"], sensitive: true, why: "You don't drink" },
    humanPos: [{ x:340, y:190 }, { x:370, y:290 }],
    aiPos:    [{ x:390, y:160 }, { x:410, y:270 }],
  },
  {
    name: 'Neuron 3',
    colorQ: { text: "Better superpower:", opts: ["Flight","Invisibility"], colors: [C.pink, C.teal] },
    posQ:   { text: "In 10 years, driving will be...", opts: ["Still manual","Self-driving"] },
    humanPos: [{ x:270, y:270 }, { x:250, y:310 }],
    aiPos:    [{ x:270, y:270 }, { x:270, y:320 }],
  },
  {
    name: 'Neuron 4',
    colorQ: { text: "Will AI replace most jobs?", opts: ["Yes, big changes","No, jobs adapt"], colors: [C.emerald, C.amber], sensitive: true, why: "About yourself" },
    posQ:   { text: "Dogs or cats?", opts: ["Dogs","Cats"], sensitive: true, why: "Different relationship" },
    humanPos: [{ x:160, y:350 }, { x:230, y:400 }],
    aiPos:    [{ x:130, y:370 }, { x:200, y:420 }],
  },
  {
    name: 'Neuron 5',
    colorQ: { text: "Will humans live on Mars by 2050?", opts: ["Yes","No"], colors: [C.cyan, C.violet], sensitive: true, why: "Different stakes" },
    posQ:   { text: "Is water wet?", opts: ["Yes","No"] },
    humanPos: [{ x:350, y:380 }, { x:380, y:420 }],
    aiPos:    [{ x:390, y:370 }, { x:410, y:420 }],
  },
];

// Connections
const HUMAN_CONNS = [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,3],[1,4]];
const AI_CONNS = [[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,4],[1,3],[0,3],[1,4]];

// ═══════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════
const colorAns = new Array(5).fill(null);
const posAns = new Array(5).fill(null);
let entity = null;

function setEntity(v) {
  entity = v;
  document.getElementById('g0').classList.toggle('sel', v===0);
  document.getElementById('g1').classList.toggle('sel', v===1);
  const et = document.getElementById('etag');
  if (v===0) { et.textContent='Biological'; et.className='entity-tag human'; }
  else { et.textContent='Artificial Intelligence'; et.className='entity-tag ai'; }
  // Flash all neurons on entity change
  for (let i=0;i<5;i++) nodes[i].flash = 0.6;
  buildUI(); updateProg();
}

function pickColor(ni, v) {
  const changed = colorAns[ni] !== v;
  colorAns[ni] = v;
  if (changed) nodes[ni].flash = 1.0;
  buildUI(); updateProg();
}

function pickPos(ni, v) {
  const changed = posAns[ni] !== v;
  posAns[ni] = v;
  if (changed) nodes[ni].flash = 0.8;
  buildUI(); updateProg();
}

function resetAll() {
  colorAns.fill(null); posAns.fill(null); entity = null;
  document.getElementById('g0').classList.remove('sel');
  document.getElementById('g1').classList.remove('sel');
  document.getElementById('etag').textContent = 'Unanswered';
  document.getElementById('etag').className = 'entity-tag';
  buildUI(); updateProg();
}

function randomize() {
  for (let i=0;i<5;i++) { colorAns[i]=Math.random()<0.5?0:1; posAns[i]=Math.random()<0.5?0:1; }
  setEntity(Math.random()<0.85?0:1);
}

function updateProg() {
  const c = colorAns.filter(a=>a!==null).length + posAns.filter(a=>a!==null).length + (entity!==null?1:0);
  document.getElementById('prog').style.width = (c/11*100)+'%';
}

function buildUI() {
  const el = document.getElementById('cards');
  el.innerHTML = '';
  NEURONS.forEach((n, i) => {
    const color = colorAns[i] !== null ? n.colorQ.colors[colorAns[i]] : '#4b5563';
    const hasSensitive = n.colorQ.sensitive || n.posQ.sensitive;
    const card = document.createElement('div');
    card.className = 'neuron-card';
    card.innerHTML = `
      <div class="neuron-hdr">
        <div class="neuron-dot" style="background:${color};box-shadow:0 0 8px ${color}"></div>
        <span class="neuron-name">${n.name}</span>
        ${hasSensitive && entity===1 ? '<span class="neuron-sens">entity-sensitive</span>' : ''}
      </div>
      <div class="q-row">
        <div class="q-type">Color${n.colorQ.sensitive && entity===1 ? ' · '+n.colorQ.why : ''}</div>
        <div class="q-text">${n.colorQ.text}</div>
        <div class="q-opts">
          <button class="q-btn${colorAns[i]===0?' sel':''}" onclick="pickColor(${i},0)">${n.colorQ.opts[0]}</button>
          <button class="q-btn${colorAns[i]===1?' sel':''}" onclick="pickColor(${i},1)">${n.colorQ.opts[1]}</button>
        </div>
      </div>
      <div class="q-row">
        <div class="q-type">Position${n.posQ.sensitive && entity===1 ? ' · '+n.posQ.why : ''}</div>
        <div class="q-text">${n.posQ.text}</div>
        <div class="q-opts">
          <button class="q-btn${posAns[i]===0?' sel':''}" onclick="pickPos(${i},0)">${n.posQ.opts[0]}</button>
          <button class="q-btn${posAns[i]===1?' sel':''}" onclick="pickPos(${i},1)">${n.posQ.opts[1]}</button>
        </div>
      </div>`;
    el.appendChild(card);
  });
}

buildUI();

// ═══════════════════════════════════════════════════════
// CANVAS
// ═══════════════════════════════════════════════════════
const canvas = document.getElementById('aura');
const ctx = canvas.getContext('2d');
const W = 540, H = 540, CX = 270, CY = 270;

function lerp(a,b,t) { return a+(b-a)*t; }
function lerpRgb(a,b,t) { return [lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)]; }

// Node state
const nodes = [];
for (let i = 0; i < 5; i++) {
  const dp = NEURONS[i].humanPos[0];
  const mid = { x: (NEURONS[i].humanPos[0].x + NEURONS[i].humanPos[1].x)/2,
                y: (NEURONS[i].humanPos[0].y + NEURONS[i].humanPos[1].y)/2 };
  nodes.push({
    x: mid.x, y: mid.y, tx: mid.x, ty: mid.y,
    color: [70,75,90], tcolor: [70,75,90],
    r: 3, tr: 3,
    alpha: 0.15, talpha: 0.15,
    phase: Math.random() * Math.PI * 2,
    flash: 0,
  });
}

// Stars
const stars = [];
for (let i=0;i<25;i++) stars.push({
  x: Math.random()*W, y: Math.random()*H,
  r: 0.3+Math.random()*0.6, phase: Math.random()*6, speed: 0.5+Math.random()*2
});

function computeTargets() {
  const isAI = entity === 1;

  for (let i = 0; i < 5; i++) {
    const n = NEURONS[i];
    const posSet = isAI ? n.aiPos : n.humanPos;

    // Position: if answered, go to that position. If not, midpoint.
    if (posAns[i] !== null) {
      nodes[i].tx = posSet[posAns[i]].x;
      nodes[i].ty = posSet[posAns[i]].y;
    } else {
      nodes[i].tx = (posSet[0].x + posSet[1].x) / 2;
      nodes[i].ty = (posSet[0].y + posSet[1].y) / 2;
    }

    // Color
    if (colorAns[i] !== null) {
      nodes[i].tcolor = hexRgb(n.colorQ.colors[colorAns[i]]);
      nodes[i].tr = 7;
      nodes[i].talpha = 1;
    } else {
      nodes[i].tcolor = [70, 75, 90];
      nodes[i].tr = 3;
      nodes[i].talpha = 0.15;
    }

    // If position is answered but color isn't, still make it somewhat visible
    if (posAns[i] !== null && colorAns[i] === null) {
      nodes[i].talpha = 0.4;
      nodes[i].tr = 4.5;
    }
    // If color is answered but position isn't, node is bright at midpoint
  }
}

let lastTime = performance.now();
let time = 0;

function frame(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  time = now / 1000;

  computeTargets();

  const spd = 8 * dt;
  const cspd = 10 * dt;
  for (let i = 0; i < 5; i++) {
    const n = nodes[i];
    n.x = lerp(n.x, n.tx, spd);
    n.y = lerp(n.y, n.ty, spd);
    n.r = lerp(n.r, n.tr + n.flash * 5, spd);
    n.alpha = lerp(n.alpha, n.talpha + n.flash * 0.3, spd);
    n.color = lerpRgb(n.color, n.tcolor, cspd);
    n.flash *= 0.91;
    if (n.flash < 0.01) n.flash = 0;
  }

  render();
  requestAnimationFrame(frame);
}

function render() {
  const isAI = entity === 1;
  const breath = 1 + Math.sin(time * 0.5) * 0.03;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#030712';
  ctx.fillRect(0, 0, W, H);

  // Stars
  for (const s of stars) {
    const tw = 0.12 + 0.2 * Math.max(0, Math.sin(time * s.speed + s.phase));
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(180,200,255,${tw})`; ctx.fill();
  }

  // AI grid
  if (isAI) {
    ctx.save(); ctx.globalAlpha = 0.03;
    ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 0.5;
    for (let ring = 1; ring <= 3; ring++) {
      ctx.beginPath();
      for (let i = 0; i <= 6; i++) {
        const a = (i/6)*Math.PI*2 - Math.PI/6;
        const r = ring * 70;
        const px = CX + Math.cos(a)*r, py = CY + Math.sin(a)*r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  // ── GLOW ──
  for (let i = 0; i < 5; i++) {
    const n = nodes[i];
    if (n.alpha < 0.05) continue;

    const dx = Math.sin(time * 0.4 + n.phase) * (isAI ? 1 : 3);
    const dy = Math.cos(time * 0.3 + n.phase * 0.7) * (isAI ? 1 : 3);
    const nx = n.x + dx, ny = n.y + dy;
    const [cr,cg,cb] = n.color;

    let glowR = n.alpha > 0.5 ? 60 : 15;
    glowR += n.flash * 35;
    glowR *= breath;
    if (isAI) glowR *= 0.8;

    const ga = n.alpha * (isAI ? 0.4 : 0.55);
    const g = ctx.createRadialGradient(nx, ny, 0, nx, ny, glowR);
    g.addColorStop(0, `rgba(${cr|0},${cg|0},${cb|0},${ga})`);
    g.addColorStop(0.5, `rgba(${cr|0},${cg|0},${cb|0},${ga*0.35})`);
    g.addColorStop(1, `rgba(${cr|0},${cg|0},${cb|0},0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(nx, ny, glowR, 0, Math.PI*2); ctx.fill();
  }

  // ── CONNECTIONS ──
  const conns = isAI ? AI_CONNS : HUMAN_CONNS;
  for (const [a, b] of conns) {
    const na = nodes[a], nb = nodes[b];
    if (na.alpha < 0.3 || nb.alpha < 0.3) continue;

    const dxa = Math.sin(time*0.4+na.phase)*(isAI?1:3);
    const dya = Math.cos(time*0.3+na.phase*0.7)*(isAI?1:3);
    const dxb = Math.sin(time*0.4+nb.phase)*(isAI?1:3);
    const dyb = Math.cos(time*0.3+nb.phase*0.7)*(isAI?1:3);
    const ax = na.x+dxa, ay = na.y+dya, bx = nb.x+dxb, by = nb.y+dyb;

    const dx = ax-bx, dy = ay-by;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const fade = Math.max(0, 1 - dist / 400);
    const alpha = fade * Math.min(na.alpha, nb.alpha) * (isAI ? 0.3 : 0.22);
    if (alpha < 0.01) continue;

    const mc = lerpRgb(na.color, nb.color, 0.5);
    ctx.beginPath();
    if (isAI) {
      ctx.moveTo(ax, ay); ctx.lineTo(bx, by);
      ctx.strokeStyle = `rgba(${mc[0]|0},${mc[1]|0},${mc[2]|0},${alpha})`;
      ctx.lineWidth = 0.8;
    } else {
      const mx = (ax+bx)/2 + Math.sin(time*0.2+a+b)*6;
      const my = (ay+by)/2 + Math.cos(time*0.2+a*b*0.1)*6;
      ctx.moveTo(ax, ay); ctx.quadraticCurveTo(mx, my, bx, by);
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
      ctx.lineWidth = 1;
    }
    ctx.stroke();
  }

  // ── NODES ──
  for (let i = 0; i < 5; i++) {
    const n = nodes[i];
    if (n.alpha < 0.05) continue;

    const dx = Math.sin(time * 0.4 + n.phase) * (isAI ? 1 : 3);
    const dy = Math.cos(time * 0.3 + n.phase * 0.7) * (isAI ? 1 : 3);
    const nx = n.x + dx, ny = n.y + dy;
    const [cr,cg,cb] = n.color;
    const r = n.r * breath;

    // Flash ring
    if (n.flash > 0.05) {
      const flashR = r * (4 + (1 - n.flash) * 10);
      ctx.beginPath(); ctx.arc(nx, ny, flashR, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(${cr|0},${cg|0},${cb|0},${n.flash * 0.5})`;
      ctx.lineWidth = 2.5 * n.flash; ctx.stroke();
    }

    if (isAI) {
      // Sharper node: less blur, more defined
      // Halo
      ctx.save();
      ctx.globalAlpha = n.alpha * 0.18;
      ctx.fillStyle = `rgb(${cr|0},${cg|0},${cb|0})`;
      ctx.shadowColor = `rgb(${cr|0},${cg|0},${cb|0})`;
      ctx.shadowBlur = 12;
      ctx.beginPath(); ctx.arc(nx, ny, r * 3, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Core
      ctx.beginPath(); ctx.arc(nx, ny, r * 1.5, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${n.alpha * 0.4})`; ctx.fill();

      ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${n.alpha * 0.95})`; ctx.fill();

      // Sharp pip
      ctx.beginPath(); ctx.arc(nx, ny, r * 0.3, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${n.alpha * 0.75})`; ctx.fill();
    } else {
      // Organic node: softer, bigger halo
      ctx.save();
      ctx.globalAlpha = n.alpha * 0.2;
      ctx.fillStyle = `rgb(${cr|0},${cg|0},${cb|0})`;
      ctx.shadowColor = `rgb(${cr|0},${cg|0},${cb|0})`;
      ctx.shadowBlur = 22;
      ctx.beginPath(); ctx.arc(nx, ny, r * 3.5, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.beginPath(); ctx.arc(nx, ny, r * 1.8, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${n.alpha * 0.35})`; ctx.fill();

      ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${n.alpha * 0.95})`; ctx.fill();

      ctx.beginPath(); ctx.arc(nx, ny, r * 0.35, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${n.alpha * 0.5})`; ctx.fill();
    }
  }
}

requestAnimationFrame(frame);
</script>
</body>
</html>
