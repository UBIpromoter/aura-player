<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aura Organism — Answer Mapping Playground</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;}
body{background:#050A18;color:#e2e8f0;display:flex;}

/* Canvas area */
.viz-area{flex:1;position:relative;min-width:0;}
canvas{display:block;width:100%;height:100%;}
.viz-info{position:absolute;bottom:12px;left:12px;font-size:10px;color:#334155;
  display:flex;gap:8px;align-items:center;letter-spacing:0.5px;}
.viz-info .trait{display:flex;align-items:center;gap:3px;}
.viz-info .dot{width:6px;height:6px;border-radius:50%;display:inline-block;}
.viz-stats{position:absolute;top:12px;left:12px;font-size:10px;color:#475569;
  letter-spacing:0.3px;line-height:1.6;}

/* Top bar controls */
.top-bar{position:absolute;top:8px;left:50%;transform:translateX(-50%);display:flex;gap:4px;
  align-items:center;z-index:10;padding:4px 8px;border-radius:8px;
  background:rgba(5,10,24,0.7);backdrop-filter:blur(8px);}
.top-bar button{border:1px solid #1e293b;padding:3px 10px;border-radius:5px;cursor:pointer;
  font-size:10px;letter-spacing:0.7px;background:rgba(15,23,42,0.6);color:#475569;
  font-family:inherit;transition:all 0.2s;}
.top-bar button:hover{background:#1e293b;color:#94a3b8;}
.top-bar button.on{background:rgba(78,205,196,0.12);color:#4ECDC4;border-color:rgba(78,205,196,0.25);}
.div{width:1px;height:16px;margin:0 2px;background:#1e293b;}

/* Sidebar */
.sidebar{width:340px;height:100vh;overflow-y:auto;overflow-x:hidden;
  background:rgba(8,12,28,0.95);border-left:1px solid #1e293b;
  padding:12px 14px;flex-shrink:0;scrollbar-width:thin;scrollbar-color:#1e293b transparent;}
.sidebar::-webkit-scrollbar{width:5px;}
.sidebar::-webkit-scrollbar-track{background:transparent;}
.sidebar::-webkit-scrollbar-thumb{background:#1e293b;border-radius:3px;}

.sidebar h1{font-size:13px;font-weight:700;color:#94a3b8;letter-spacing:1px;
  text-transform:uppercase;margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid #1e293b;}

/* Presets */
.presets{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:16px;}
.presets button{border:1px solid #1e293b;padding:4px 10px;border-radius:6px;cursor:pointer;
  font-size:10px;background:rgba(15,23,42,0.6);color:#64748b;font-family:inherit;
  transition:all 0.15s;letter-spacing:0.3px;}
.presets button:hover{background:#1e293b;color:#94a3b8;}
.presets button.active{background:rgba(78,205,196,0.1);color:#4ECDC4;border-color:rgba(78,205,196,0.25);}

/* Section */
.section{margin-bottom:16px;}
.section-header{display:flex;align-items:center;justify-content:space-between;
  cursor:pointer;padding:6px 0;user-select:none;}
.section-header h2{font-size:11px;font-weight:600;letter-spacing:0.8px;text-transform:uppercase;}
.section-header .indicator{font-size:10px;color:#475569;transition:transform 0.2s;}
.section-header:hover h2{color:#e2e8f0;}
.section.collapsed .section-body{display:none;}
.section.collapsed .indicator{transform:rotate(-90deg);}
.section-body{padding:4px 0 4px 0;}
.section-actions{display:flex;gap:4px;align-items:center;}
.section-actions button{border:none;background:none;color:#475569;font-size:9px;
  cursor:pointer;padding:2px 6px;border-radius:3px;font-family:inherit;}
.section-actions button:hover{background:rgba(255,255,255,0.05);color:#94a3b8;}

/* Slider row */
.slider-row{display:flex;align-items:center;gap:8px;margin:5px 0;height:24px;}
.slider-label{width:56px;font-size:10px;color:#64748b;letter-spacing:0.3px;flex-shrink:0;
  text-align:right;font-weight:500;}
.slider-wrap{flex:1;position:relative;height:20px;display:flex;align-items:center;}
.slider-wrap input[type=range]{width:100%;height:4px;-webkit-appearance:none;appearance:none;
  background:transparent;outline:none;cursor:pointer;}
.slider-wrap input[type=range]::-webkit-slider-track{height:4px;border-radius:2px;
  background:linear-gradient(to right, var(--track-color, #1e293b) 0%, var(--track-color, #1e293b) 100%);}
.slider-wrap input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;
  border-radius:50%;background:var(--thumb-color, #4ECDC4);border:2px solid #0f172a;
  box-shadow:0 0 6px var(--glow-color, rgba(78,205,196,0.3));cursor:grab;}
.slider-wrap input[type=range]::-webkit-slider-thumb:active{cursor:grabbing;
  box-shadow:0 0 12px var(--glow-color, rgba(78,205,196,0.5));}
.slider-value{width:36px;font-size:10px;color:#94a3b8;text-align:left;font-variant-numeric:tabular-nums;
  flex-shrink:0;}

/* Section colors */
.sec-bigfive .section-header h2{color:#4ECDC4;}
.sec-bigfive .slider-wrap{--track-color:#0d3d38;--thumb-color:#4ECDC4;--glow-color:rgba(78,205,196,0.3);}

.sec-shadow .section-header h2{color:#64748b;}
.sec-shadow .slider-wrap{--track-color:#1e293b;--thumb-color:#64748b;--glow-color:rgba(100,116,139,0.3);}

.sec-attach .section-header h2{color:#f43f5e;}
.sec-attach .slider-wrap{--track-color:#3b1522;--thumb-color:#f43f5e;--glow-color:rgba(244,63,94,0.3);}

.sec-risk .section-header h2{color:#f59e0b;}
.sec-risk .slider-wrap{--track-color:#3b2f0b;--thumb-color:#f59e0b;--glow-color:rgba(245,158,11,0.3);}

.sec-chrono .section-header h2{color:#3b82f6;}
.sec-chrono .slider-wrap{--track-color:#0f2447;--thumb-color:#3b82f6;--glow-color:rgba(59,130,246,0.3);}

.sec-adhd .section-header h2{color:#8b5cf6;}
.sec-adhd .slider-wrap{--track-color:#1e1547;--thumb-color:#8b5cf6;--glow-color:rgba(139,92,246,0.3);}

.sec-global .section-header h2{color:#94a3b8;}
.sec-global .slider-wrap{--track-color:#1e293b;--thumb-color:#94a3b8;--glow-color:rgba(148,163,184,0.3);}

.sec-motion .section-header h2{color:#06b6d4;}
.sec-motion .slider-wrap{--track-color:#0b3040;--thumb-color:#06b6d4;--glow-color:rgba(6,182,212,0.3);}

.sec-membrane .section-header h2{color:#10b981;}
.sec-membrane .slider-wrap{--track-color:#0b3024;--thumb-color:#10b981;--glow-color:rgba(16,185,129,0.3);}

.sec-glow .section-header h2{color:#d946ef;}
.sec-glow .slider-wrap{--track-color:#2d1538;--thumb-color:#d946ef;--glow-color:rgba(217,70,239,0.3);}

/* Mapping info */
.mapping-note{font-size:9px;color:#334155;padding:2px 0 6px 64px;line-height:1.4;
  font-style:italic;}

/* Toggle sidebar */
.sidebar-toggle{position:absolute;top:50%;right:340px;transform:translateY(-50%);
  z-index:20;background:rgba(8,12,28,0.9);border:1px solid #1e293b;border-right:none;
  border-radius:6px 0 0 6px;padding:8px 4px;cursor:pointer;color:#475569;font-size:14px;
  transition:right 0.3s;}
.sidebar-toggle:hover{color:#94a3b8;background:#0f172a;}
body.sidebar-hidden .sidebar{display:none;}
body.sidebar-hidden .sidebar-toggle{right:0;}
</style>
</head>
<body>

<div class="viz-area">
  <canvas id="c"></canvas>
  <div class="top-bar">
    <button onclick="sS(0)" id="s0">Seed</button>
    <button onclick="sS(1)" id="s1">Young</button>
    <button onclick="sS(2)" id="s2">Growing</button>
    <button onclick="sS(3)" id="s3" class="on">Full</button>
    <div class="div"></div>
    <button onclick="sE('human')" id="eh" class="on">Human</button>
    <button onclick="sE('ai')" id="ea">AI</button>
    <div class="div"></div>
    <button onclick="sT('dark')" id="td" class="on">Dark</button>
    <button onclick="sT('light')" id="tl">Light</button>
  </div>
  <div class="viz-info" id="info"></div>
  <div class="viz-stats" id="stats"></div>
</div>

<button class="sidebar-toggle" onclick="toggleSidebar()" id="sidebarToggle">◀</button>

<div class="sidebar" id="sidebar">
  <h1>Answer → Viz Mapping</h1>

  <!-- Presets -->
  <div class="presets" id="presets"></div>

  <!-- Big Five -->
  <div class="section sec-bigfive" id="sec-bigfive">
    <div class="section-header" onclick="toggleSection('sec-bigfive')">
      <h2>Big Five Personality</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('bigFive')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-bigfive"></div>
    <div class="mapping-note">Primary node size, glow intensity, orbital radius</div>
  </div>

  <!-- Shadow -->
  <div class="section sec-shadow" id="sec-shadow">
    <div class="section-header" onclick="toggleSection('sec-shadow')">
      <h2>Shadow Self (Dark Triad)</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('shadow')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-shadow"></div>
    <div class="mapping-note">Color saturation shift, node edge sharpness, pulse irregularity</div>
  </div>

  <!-- Attachment -->
  <div class="section sec-attach" id="sec-attach">
    <div class="section-header" onclick="toggleSection('sec-attach')">
      <h2>Attachment Style</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('attachment')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-attach"></div>
    <div class="mapping-note">Connection density, pulse speed, membrane breathing rate</div>
  </div>

  <!-- Risk -->
  <div class="section sec-risk" id="sec-risk">
    <div class="section-header" onclick="toggleSection('sec-risk')">
      <h2>Risk Profile</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('risk')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-risk"></div>
    <div class="mapping-note">Drift amplitude, wander range, chaos factor</div>
  </div>

  <!-- Chronotype -->
  <div class="section sec-chrono" id="sec-chrono">
    <div class="section-header" onclick="toggleSection('sec-chrono')">
      <h2>Chronotype</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('chronotype')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-chrono"></div>
    <div class="mapping-note">Animation speed, energy rhythm, breathing tempo</div>
  </div>

  <!-- ADHD -->
  <div class="section sec-adhd" id="sec-adhd">
    <div class="section-header" onclick="toggleSection('sec-adhd')">
      <h2>ADHD Indicators</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();randomizeSection('adhd')">dice</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-adhd"></div>
    <div class="mapping-note">Micro-wiggle amplitude, attention scatter, node restlessness</div>
  </div>

  <!-- Motion Modifiers -->
  <div class="section sec-motion" id="sec-motion">
    <div class="section-header" onclick="toggleSection('sec-motion')">
      <h2>Motion (Derived)</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();resetMotion()">reset</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-motion"></div>
    <div class="mapping-note">Override derived motion values manually</div>
  </div>

  <!-- Glow -->
  <div class="section sec-glow collapsed" id="sec-glow">
    <div class="section-header" onclick="toggleSection('sec-glow')">
      <h2>Glow & Light</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();resetGlow()">reset</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-glow"></div>
    <div class="mapping-note">Glow radius, intensity, passes, halo scale</div>
  </div>

  <!-- Membrane -->
  <div class="section sec-membrane collapsed" id="sec-membrane">
    <div class="section-header" onclick="toggleSection('sec-membrane')">
      <h2>Membrane</h2>
      <div class="section-actions">
        <button onclick="event.stopPropagation();resetMembrane()">reset</button>
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-membrane"></div>
    <div class="mapping-note">Membrane opacity, breathing amplitude, thickness</div>
  </div>

  <!-- Global -->
  <div class="section sec-global collapsed" id="sec-global">
    <div class="section-header" onclick="toggleSection('sec-global')">
      <h2>Global</h2>
      <div class="section-actions">
        <span class="indicator">▼</span>
      </div>
    </div>
    <div class="section-body" id="body-global"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// AURA ORGANISM — ANSWER MAPPING PLAYGROUND v1
// Fork of v20 with comprehensive parameter controls
// ═══════════════════════════════════════════════════════════════

const PI=Math.PI, TAU=PI*2;

// ═══ TRAIT DEFINITIONS ═══
const TR={
  O:{l:'Openness',     base:[78,205,196],  acc:[255,154,139]},
  C:{l:'Conscientiousness', base:[69,183,209],  acc:[255,183,77]},
  E:{l:'Extraversion', base:[150,230,161], acc:[230,120,200]},
  A:{l:'Agreeableness',base:[221,160,221], acc:[120,220,180]},
  N:{l:'Neuroticism',  base:[247,220,111], acc:[140,160,240]}
};
const TK=Object.keys(TR);
const SSC=[0.20,0.45,0.72,1.0], GSC=[0.35,0.55,0.78,1.0];

// ═══ SCORE STATE — the master control object ═══
const scores = {
  bigFive:    { O:65, C:55, E:70, A:60, N:40 },
  shadow:     { M:25, N:20, P:15 },
  attachment: { anxiety:1.5, avoidance:1.5 },
  risk:       { financial:40, social:50, physical:30, ethical:35 },
  chronotype: 55,     // 0=night owl → 100=morning lark
  adhd:       1,      // 0-6 indicators
  depth:      4,      // 0-20 assessments completed
};

// ═══ DERIVED MODIFIERS (some auto-derived, some manually overridable) ═══
const mods = {
  // Motion
  driftAmp:     1.0,    // wander amplitude multiplier
  driftSpeed:   1.0,    // wander speed multiplier
  swayAmp:      1.0,    // visible sway multiplier
  wiggleAmp:    1.0,    // micro-wiggle multiplier
  wiggleSpeed:  1.0,    // wiggle frequency
  breathRate:   1.0,    // membrane breathing speed
  breathAmp:    1.0,    // membrane breathing amount
  pulseSpeed:   1.0,    // energy pulse speed
  // Glow
  glowRadius:   1.0,    // glow extent
  glowIntensity:1.0,    // glow alpha multiplier
  // Membrane
  memOpacity:   1.0,    // membrane line opacity
  memThickness: 1.0,    // membrane line width
  // Shadow effects
  satShift:     0.0,    // color saturation shift from shadow
  edgeSharp:    0.0,    // node edge sharpness from shadow
  // Connection
  connDensity:  1.0,    // K-nearest for connections
  connPulseIrr: 0.0,    // pulse irregularity
};

let modsOverride = {}; // manual overrides lock out auto-derivation

// ═══ CANVAS STATE ═══
let cvs,ctx,CW,CH,CX,CY,oR;
let ent='human',thm='dark',stg=3;
let gen,allN,actN,cons,puls;
let t0=0,tL=0;
let hullPts=[];

// ═══ HELPERS ═══
function m32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;};}
function rga(c,a){return`rgba(${c[0]|0},${c[1]|0},${c[2]|0},${a})`;}
function ltn(c,n){return[Math.min(255,c[0]+n),Math.min(255,c[1]+n),Math.min(255,c[2]+n)];}
function drk(c,n){return[Math.max(0,c[0]-n),Math.max(0,c[1]-n),Math.max(0,c[2]-n)];}
function dst(x1,y1,x2,y2){const a=x1-x2,b=y1-y2;return Math.sqrt(a*a+b*b);}
function bl(cs,ws){let r=0,g=0,b=0,w=0;for(let i=0;i<cs.length;i++){r+=cs[i][0]*ws[i];g+=cs[i][1]*ws[i];b+=cs[i][2]*ws[i];w+=ws[i];}return w?[r/w|0,g/w|0,b/w|0]:[128,128,128];}
function lr3(a,b,t){return[a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t,a[2]+(b[2]-a[2])*t];}
function sat(c,s){const g=0.299*c[0]+0.587*c[1]+0.114*c[2];return[Math.min(255,g+(c[0]-g)*s)|0,Math.min(255,g+(c[1]-g)*s)|0,Math.min(255,g+(c[2]-g)*s)|0];}
function clamp(v,lo,hi){return v<lo?lo:v>hi?hi:v;}

// Value noise
const PERM=new Uint8Array(512);
(function(){const r=m32(42);for(let i=0;i<256;i++)PERM[i]=i;
  for(let i=255;i>0;i--){const j=(r()*i)|0;[PERM[i],PERM[j]]=[PERM[j],PERM[i]];}
  for(let i=0;i<256;i++)PERM[i+256]=PERM[i];})();
function noise2(x,y){
  const xi=Math.floor(x)&255,yi=Math.floor(y)&255,xf=x-Math.floor(x),yf=y-Math.floor(y);
  const u=xf*xf*(3-2*xf),v=yf*yf*(3-2*yf);
  const a=PERM[xi]+yi,b=PERM[xi+1]+yi;
  return((PERM[a]/255*(1-u)+PERM[b]/255*u)*(1-v)+(PERM[a+1]/255*(1-u)+PERM[b+1]/255*u)*v);
}
function fbm(x,y,oct){let v=0,a=0.5,f=1;for(let i=0;i<oct;i++){v+=a*noise2(x*f,y*f);a*=0.5;f*=2;}return v;}

// Convex hull
function convexHull(points){
  if(points.length<3) return points.slice();
  const sorted=points.slice().sort((a,b)=>a.x-b.x||a.y-b.y);
  const cross=(O,A,B)=>(A.x-O.x)*(B.y-O.y)-(A.y-O.y)*(B.x-O.x);
  const lower=[];
  for(const p of sorted){while(lower.length>=2&&cross(lower[lower.length-2],lower[lower.length-1],p)<=0) lower.pop();lower.push(p);}
  const upper=[];
  for(let i=sorted.length-1;i>=0;i--){const p=sorted[i];while(upper.length>=2&&cross(upper[upper.length-2],upper[upper.length-1],p)<=0) upper.pop();upper.push(p);}
  return lower.slice(0,-1).concat(upper.slice(0,-1));
}
function chaikin(pts, iters){
  let cur=pts;
  for(let it=0;it<iters;it++){
    const next=[];
    for(let i=0;i<cur.length;i++){
      const a=cur[i], b=cur[(i+1)%cur.length];
      next.push({x:a.x*0.75+b.x*0.25, y:a.y*0.75+b.y*0.25});
      next.push({x:a.x*0.25+b.x*0.75, y:a.y*0.25+b.y*0.75});
    }
    cur=next;
  }
  return cur;
}

// ═══ DERIVE MODIFIERS FROM SCORES ═══
function deriveModifiers() {
  const s = scores;

  // Shadow → saturation shift, edge sharpness, pulse irregularity
  const shadowAvg = (s.shadow.M + s.shadow.N + s.shadow.P) / 300;
  if (!('satShift' in modsOverride))    mods.satShift = shadowAvg * 0.6;       // 0-0.6
  if (!('edgeSharp' in modsOverride))   mods.edgeSharp = shadowAvg * 0.5;      // 0-0.5
  if (!('connPulseIrr' in modsOverride)) mods.connPulseIrr = shadowAvg * 0.8;  // 0-0.8

  // Attachment → connection density, pulse speed, breathing
  const anxNorm = s.attachment.anxiety / 5;   // 0-1
  const avdNorm = s.attachment.avoidance / 5; // 0-1
  if (!('connDensity' in modsOverride)) mods.connDensity = 0.5 + anxNorm * 1.0;      // 0.5-1.5
  if (!('pulseSpeed' in modsOverride))  mods.pulseSpeed = 0.6 + anxNorm * 0.8;       // 0.6-1.4
  if (!('breathRate' in modsOverride))  mods.breathRate = 0.7 + anxNorm * 0.6 - avdNorm * 0.2;
  if (!('breathAmp' in modsOverride))   mods.breathAmp = 0.5 + anxNorm * 1.0;

  // Risk → drift amplitude, wander range
  const riskAvg = (s.risk.financial + s.risk.social + s.risk.physical + s.risk.ethical) / 400;
  if (!('driftAmp' in modsOverride))   mods.driftAmp = 0.4 + riskAvg * 1.2;    // 0.4-1.6
  if (!('driftSpeed' in modsOverride)) mods.driftSpeed = 0.6 + riskAvg * 0.8;  // 0.6-1.4
  if (!('swayAmp' in modsOverride))    mods.swayAmp = 0.5 + riskAvg * 1.0;

  // Chronotype → animation speed, energy
  const chronoNorm = s.chronotype / 100;
  if (!('wiggleSpeed' in modsOverride)) mods.wiggleSpeed = 0.5 + chronoNorm * 1.0;

  // ADHD → wiggle amplitude
  const adhdNorm = s.adhd / 6;
  if (!('wiggleAmp' in modsOverride)) mods.wiggleAmp = 0.3 + adhdNorm * 2.0;

  // Depth → stage
  stg = s.depth >= 4 ? 3 : s.depth >= 2 ? 2 : s.depth >= 1 ? 1 : 0;
  for (let j=0;j<4;j++) document.getElementById('s'+j).classList.toggle('on', j===stg);
}

// ═══ GENOME FROM SCORES ═══
function mkGen() {
  const bf = scores.bigFive;
  const tv = {};
  // Big Five scores → trait values (0-1)
  for (const k of TK) tv[k] = clamp(bf[k] / 100, 0.01, 1.0);

  // Stable seed from trait profile
  let seed = 12345;
  for (const k of TK) seed = (seed * 31 + Math.round(tv[k] * 1000)) | 0;
  seed = Math.abs(seed) || 42;

  const so = [...TK].sort((a, b) => tv[b] - tv[a]);
  const glow = bl([TR[so[0]].base, TR[so[1]].base], [0.65, 0.35]);
  const r = m32(seed);
  const iord = [0,1,2,3,4,5].sort(() => r() - 0.5);
  const ints = {}; for (let i=0;i<5;i++) ints[TK[i]] = iord[i];
  return { tv, s:seed, dom:so[0], glow, glowAcc:TR[so[0]].acc, ints, so };
}

// ═══ NODES ═══
function mkNodes(g) {
  const r=m32(g.s+3333), ns=[];

  // Primaries
  for(let i=0;i<5;i++){
    const k=TK[i], v=g.tv[k];
    const an=(i/5)*TAU-PI/2 + (v-0.5)*0.3;
    const br=oR*(0.28+0.22*v);
    const rd=oR*(0.06+v*0.14);
    ns.push({tp:'p',k,tv:v,rgb:TR[k].base,acc:TR[k].acc,iIdx:g.ints[k],
      bA:an,bR:br,x:0,y:0,dp:0,rd,sd:g.s+i*137.5,bp:i*1.47,stg:0});
  }

  // Companions — 5 per primary
  for(let i=0;i<5;i++){const p=ns[i];for(let c=0;c<5;c++){
    const o=p.bA+(c-2)*0.3+(r()-0.5)*0.2, cr=p.bR+oR*(0.04+r()*0.06);
    const v=p.tv*(0.25+r()*0.35);
    ns.push({tp:'c',k:p.k,tv:v,rgb:p.rgb,acc:p.acc,
      bA:o,bR:cr,x:0,y:0,dp:0,rd:oR*(0.010+v*0.025),sd:g.s+(10+i*5+c)*137.5,bp:(10+i*5+c)*0.9,stg:1});
  }}

  // Accessories — ring 1 and 2
  const AD=[
    {a:['O','C'],n:5},{a:['E','N'],n:5},{a:['O'],n:4},{a:['E','A'],n:5},{a:['C','N'],n:4},
    {a:['O','C','E','A','N'],n:7},{a:['A','E'],n:5},{a:['N','O'],n:5},
    {a:['O','E'],n:4},{a:['C','A'],n:4},{a:['N','E','A'],n:5}
  ];
  let ai=0;
  for(let a=0;a<AD.length;a++){const d=AD[a],sr2=a<5?2:3;
    for(let n=0;n<d.n;n++){
      const ak=d.a[n%d.a.length],ai2=TK.indexOf(ak),ap=ns[ai2];
      const sc=oR*(0.04+r()*0.10),v=ap.tv*(0.12+r()*0.22);
      const nb=ns[(ai2+1+Math.floor(r()*3))%5];
      const rgb=lr3(ap.rgb,nb.acc,0.15+r()*0.2).map(x=>clamp(x|0,0,255));
      ns.push({tp:'a',k:ak,tv:v,rgb,acc:ap.acc,
        bA:ap.bA+(r()-0.5)*0.8,bR:ap.bR+sc*(0.5+r()*0.5),x:0,y:0,dp:0,
        rd:oR*(0.004+v*0.012),sd:g.s+(40+ai)*137.5,bp:(40+ai)*0.7,stg:sr2});ai++;
  }}

  // Halo ring
  for(let h=0;h<18;h++){
    const ha=(h/18)*TAU+(r()-0.5)*0.3;
    const pi=h%5,pp=ns[pi],v=pp.tv*(0.08+r()*0.12);
    const hr=pp.bR+oR*(0.02+r()*0.06);
    const rgb=lr3(pp.rgb,pp.acc,0.2+r()*0.3).map(x=>clamp(x|0,0,255));
    ns.push({tp:'a',k:TK[pi],tv:v,rgb,acc:pp.acc,
      bA:ha,bR:hr,x:0,y:0,dp:0,rd:oR*(0.003+v*0.006),sd:g.s+(120+h)*137.5,bp:(120+h)*0.5,stg:3});
  }
  return ns;
}

function filt(ns,si){return ns.filter(n=>n.tp==='p'||(n.tp==='c'&&si>=1)||(n.tp==='a'&&si>=n.stg));}

// ═══ CONTOUR ═══
function computeHull(ns){
  const sc=SSC[stg], pts=[];
  for(const n of ns){
    const r=n.rd*sc;
    const pad=n.tp==='p' ? r*0.6+oR*0.06 : r*0.5+oR*0.04;
    const totalR=r+pad;
    for(let i=0;i<24;i++){
      const a=(i/24)*TAU;
      pts.push({x:n.x+Math.cos(a)*totalR, y:n.y+Math.sin(a)*totalR});
    }
  }
  if(pts.length<3) return [{x:CX-20,y:CY-20},{x:CX+20,y:CY-20},{x:CX+20,y:CY+20},{x:CX-20,y:CY+20}];
  return chaikin(convexHull(pts), 8);
}

function traceSmoothedHull(ctx,hull){
  if(hull.length<3) return;
  ctx.beginPath();
  ctx.moveTo(hull[0].x, hull[0].y);
  for(let i=1;i<hull.length;i++) ctx.lineTo(hull[i].x, hull[i].y);
  ctx.closePath();
}

// ═══ PHYSICS — with modifier integration ═══
function updPhys(ns,t){
  const breathVal = Math.sin(t * 0.12 * mods.breathRate) * 0.003 * mods.breathAmp;
  const sc=SSC[stg];
  const bsc=1+breathVal;

  for(const n of ns){
    const tOff=n.sd*0.37;

    // SLOW WANDER — modulated by driftAmp and driftSpeed
    const wA = n.bA + (fbm(n.sd*0.13, t*0.004*mods.driftSpeed+tOff, 3)-0.5)*TAU*0.65*mods.driftAmp;
    const wR = n.bR*(0.75+fbm(n.sd*0.17+100, t*0.005*mods.driftSpeed+tOff, 3)*0.50*mods.driftAmp);

    const baseX=CX+Math.cos(wA)*wR*bsc*sc;
    const baseY=CY+Math.sin(wA)*wR*bsc*sc;

    // VISIBLE SWAY — modulated by swayAmp
    const swayA=oR*sc*0.15*mods.swayAmp;
    const sx=(fbm(n.sd*0.1+t*0.035+tOff, t*0.028, 2)*2-1)*swayA;
    const sy=(fbm(t*0.030, n.sd*0.1+t*0.038+tOff, 2)*2-1)*swayA;

    // MICRO-WIGGLE — modulated by wiggleAmp and wiggleSpeed
    const wigA=oR*sc*0.03*mods.wiggleAmp;
    const wx=(fbm(n.sd*0.3+t*0.15*mods.wiggleSpeed, t*0.12*mods.wiggleSpeed, 1)*2-1)*wigA;
    const wy=(fbm(t*0.13*mods.wiggleSpeed, n.sd*0.3+t*0.16*mods.wiggleSpeed, 1)*2-1)*wigA;

    n.x=baseX+sx+wx;
    n.y=baseY+sy+wy;
  }

  // Center on viewport
  let cx=0,cy=0;
  for(const n of ns){cx+=n.x;cy+=n.y;}
  cx/=ns.length;cy/=ns.length;
  const ox=CX-cx, oy=CY-cy;
  for(const n of ns){n.x+=ox;n.y+=oy;}

  hullPts=computeHull(ns);
}

// ═══ CONNECTIONS — modulated by connDensity ═══
function mkCon(ns){
  const cn=[],seen=new Set();
  const K=Math.max(3, Math.round(7 * mods.connDensity));
  for(let i=0;i<ns.length;i++){const dd=[];
    for(let j=0;j<ns.length;j++){if(i===j)continue;
      const xi=CX+Math.cos(ns[i].bA)*ns[i].bR, yi=CY+Math.sin(ns[i].bA)*ns[i].bR;
      const xj=CX+Math.cos(ns[j].bA)*ns[j].bR, yj=CY+Math.sin(ns[j].bA)*ns[j].bR;
      dd.push({j,d:dst(xi,yi,xj,yj)});}
    dd.sort((a,b)=>a.d-b.d);
    for(let k=0;k<Math.min(K,dd.length);k++){const j=dd[k].j,ky=Math.min(i,j)+'-'+Math.max(i,j);
      if(seen.has(ky))continue;seen.add(ky);
      cn.push({a:i,b:j,col:bl([ns[i].rgb,ns[j].rgb],[0.5,0.5]),
        str:(ns[i].tv+ns[j].tv)/2,cs:i*31+j*17,
        isPP:ns[i].tp==='p'&&ns[j].tp==='p'});}}
  // Ensure all primary-primary connections
  const pI=[];ns.forEach((n,i)=>{if(n.tp==='p')pI.push(i);});
  for(let i=0;i<pI.length;i++)for(let j=i+1;j<pI.length;j++){
    const ky=pI[i]+'-'+pI[j];
    if(!seen.has(ky)){seen.add(ky);const a=ns[pI[i]],b=ns[pI[j]];
      cn.push({a:pI[i],b:pI[j],col:bl([a.rgb,b.rgb],[0.5,0.5]),
        str:(a.tv+b.tv)/2,cs:pI[i]*31+pI[j]*17,isPP:true});}}
  return cn;
}

function mkPul(cn,sd){
  const r=m32(sd+5555),ps=[];
  for(const c of cn){const ct=1+Math.floor(c.str*1.5);
    for(let i=0;i<ct;i++){
      // Add irregularity from connPulseIrr
      const baseSpeed = 0.03+r()*0.05;
      const irrFactor = 1 + (r()-0.5) * mods.connPulseIrr * 2;
      ps.push({a:c.a,b:c.b,cs:c.cs,p:r(),sp:baseSpeed*irrFactor*mods.pulseSpeed,
        dr:r()>0.5?1:-1,col:ltn(c.col,55),sz:0.8+c.str*1.5+(c.isPP?1:0)});
    }
  }
  return ps;
}
function updPul(ps,dt){for(const q of ps){q.p+=q.sp*q.dr*dt;if(q.p>1)q.p-=1;if(q.p<0)q.p+=1;}}
function cMid(a,b){return{x:(a.x+b.x)/2,y:(a.y+b.y)/2};}

// ═══ BLOB PATH ═══
function blobP(ctx,cx,cy,r,sd,t){
  // Edge sharpness: 0 = blobby, 0.5 = almost circle
  const sharp = mods.edgeSharp;
  const wob = 1 - sharp;
  ctx.beginPath();for(let i=0;i<=48;i++){const a=(i/48)*TAU;
    const br=r+wob*(Math.sin(a*3+t*0.12+sd)*r*0.08+Math.sin(a*5+t*0.07+sd*1.3)*r*0.04
      +Math.sin(a*2+t*0.15+sd*0.7)*r*0.05);
    ctx.lineTo(cx+Math.cos(a)*br,cy+Math.sin(a)*br);}
  ctx.closePath();
}

// ═══ INTERIORS ═══
const INT=[
{name:'Chromatin',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*8901|0),b=ltn(col,85),h=ltn(col,140);
  for(let s=0;s<9;s++){const sa=sr()*TAU,sR=sr()*r*0.35;
    let px=n.x+Math.cos(sa)*sR,py=n.y+Math.sin(sa)*sR;
    cx.beginPath();cx.moveTo(px,py);
    for(let p=0;p<30;p++){const da=sr()*1.0-0.5+Math.sin(t*0.03+s+p*0.3)*0.15,step=r*0.04+sr()*r*0.025;
      px+=Math.cos(da+p*0.5+s)*step;py+=Math.sin(da+p*0.7+s)*step;cx.lineTo(px,py);}
    cx.strokeStyle=rga(b,0.5);cx.lineWidth=0.7+sr()*0.5;cx.lineCap='round';cx.stroke();}
  for(let i=0;i<8;i++){const a=sr()*TAU,dd=sr()*r*0.6;
    const jx=n.x+Math.cos(a)*dd,jy=n.y+Math.sin(a)*dd,sz=1+sr()*2;
    const jg=cx.createRadialGradient(jx,jy,0,jx,jy,sz*3);
    jg.addColorStop(0,rga(h,0.7));jg.addColorStop(0.4,rga(b,0.2));jg.addColorStop(1,rga(b,0));
    cx.fillStyle=jg;cx.beginPath();cx.arc(jx,jy,sz*3,0,TAU);cx.fill();}}},
{name:'Constellation',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*7913|0),b=ltn(col,90),h=ltn(col,140);
  const stars=14+Math.floor(sr()*8),pts=[];
  for(let i=0;i<stars;i++){const a=sr()*TAU,dd=r*0.08+sr()*r*0.7;
    pts.push({x:n.x+Math.cos(a)*dd,y:n.y+Math.sin(a)*dd});}
  for(let i=0;i<pts.length;i++)for(let j=i+1;j<pts.length;j++){
    const dd=dst(pts[i].x,pts[i].y,pts[j].x,pts[j].y);
    if(dd<r*0.8&&sr()>0.2){cx.beginPath();cx.moveTo(pts[i].x,pts[i].y);cx.lineTo(pts[j].x,pts[j].y);
      cx.strokeStyle=rga(b,0.2*(1-dd/(r*0.8)));cx.lineWidth=0.3;cx.stroke();}}
  for(const p of pts){const sz=2+sr()*3;
    const sg=cx.createRadialGradient(p.x,p.y,0,p.x,p.y,sz*2);
    sg.addColorStop(0,rga(h,0.85));sg.addColorStop(0.4,rga(b,0.2));sg.addColorStop(1,rga(b,0));
    cx.fillStyle=sg;cx.beginPath();cx.arc(p.x,p.y,sz*2,0,TAU);cx.fill();}}},
{name:'Vesicles',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*4567|0),b=ltn(col,70),h=ltn(col,120);
  const ct=8+Math.floor(sr()*7+n.tv*5);
  for(let i=0;i<ct;i++){const a=sr()*TAU,dd=r*0.12+sr()*r*0.55,sz=r*0.06+sr()*r*0.12;
    const vx=n.x+Math.cos(a)*dd,vy=n.y+Math.sin(a)*dd;
    blobP(cx,vx,vy,sz,n.sd+i*71,t);cx.fillStyle=rga(drk(b,20),0.45);cx.fill();
    blobP(cx,vx,vy,sz,n.sd+i*71,t);cx.strokeStyle=rga(b,0.25);cx.lineWidth=0.5;cx.stroke();
    const vg=cx.createRadialGradient(vx,vy,0,vx,vy,sz*0.6);
    vg.addColorStop(0,rga(h,0.4));vg.addColorStop(1,rga(h,0));
    cx.fillStyle=vg;cx.beginPath();cx.arc(vx,vy,sz*0.6,0,TAU);cx.fill();}}},
{name:'Axon Tree',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*1234|0),b=ltn(col,100),h=ltn(col,150);
  const arms=4+Math.floor(sr()*2);
  for(let a=0;a<arms;a++){const bA=(a/arms)*TAU+sr()*0.5;
    let px=n.x,py=n.y,ca=bA,lw=2.5+sr()*1.5;
    for(let seg=0;seg<12;seg++){const len=(r*0.1)*(1-seg*0.035)+sr()*r*0.025;
      const nx2=px+Math.cos(ca)*len,ny2=py+Math.sin(ca)*len;
      cx.beginPath();cx.moveTo(px,py);cx.lineTo(nx2,ny2);
      cx.strokeStyle=rga(b,0.55*(1-seg*0.06));cx.lineWidth=lw;cx.lineCap='round';cx.stroke();
      px=nx2;py=ny2;ca+=sr()*0.7-0.35;lw*=0.82;
      if(seg>2&&sr()>0.35){const ba2=ca+(sr()>0.5?0.5:-0.5);let bx=px,by=py,bw=lw*0.7;
        for(let bb=0;bb<5;bb++){const bx2=bx+Math.cos(ba2+sr()*0.3)*r*0.05,by2=by+Math.sin(ba2+sr()*0.3)*r*0.05;
          cx.beginPath();cx.moveTo(bx,by);cx.lineTo(bx2,by2);
          cx.strokeStyle=rga(b,0.35*(1-bb*0.12));cx.lineWidth=bw;cx.lineCap='round';cx.stroke();
          bx=bx2;by=by2;bw*=0.7;}}}}
  const sg=cx.createRadialGradient(n.x,n.y,0,n.x,n.y,r*0.22);
  sg.addColorStop(0,rga(h,0.85));sg.addColorStop(0.4,rga(b,0.35));sg.addColorStop(1,rga(b,0));
  cx.fillStyle=sg;cx.beginPath();cx.arc(n.x,n.y,r*0.22,0,TAU);cx.fill();}},
{name:'Membrane Folds',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*6802|0),b=ltn(col,80),h=ltn(col,130);
  for(let L=0;L<7;L++){const lr2=r*(0.1+L*0.12),wa=lr2*0.15+sr()*lr2*0.1;
    cx.beginPath();for(let s=0;s<=48;s++){const a=(s/48)*TAU;
      const w=Math.sin(a*3+t*0.05+L*2+sr()*5)*wa+Math.sin(a*5+t*0.03+L)*wa*0.4;
      cx.lineTo(n.x+Math.cos(a)*(lr2+w),n.y+Math.sin(a)*(lr2+w));}
    cx.closePath();cx.strokeStyle=rga(b,0.42*(1-L*0.06));cx.lineWidth=0.7+sr()*0.4;cx.stroke();}
  for(let i=0;i<10;i++){const a=sr()*TAU;
    cx.beginPath();cx.moveTo(n.x+Math.cos(a)*r*0.1,n.y+Math.sin(a)*r*0.1);
    cx.lineTo(n.x+Math.cos(a+sr()*0.2)*r*0.75,n.y+Math.sin(a+sr()*0.2)*r*0.75);
    cx.strokeStyle=rga(h,0.15);cx.lineWidth=0.3;cx.stroke();}}},
{name:'Synaptic',fn(cx,n,r,col,d,t){
  const sr=m32(n.sd*3456|0),b=ltn(col,80),h=ltn(col,130);
  const arms=6+Math.floor(sr()*3),jns=[];
  for(let a=0;a<arms;a++){const ba=(a/arms)*TAU+sr()*0.4;
    let px=n.x,py=n.y,ca=ba;
    for(let s=0;s<8;s++){const len=r*0.09+sr()*r*0.05,nx2=px+Math.cos(ca)*len,ny2=py+Math.sin(ca)*len;
      cx.beginPath();cx.moveTo(px,py);cx.lineTo(nx2,ny2);
      cx.strokeStyle=rga(b,0.45*(1-s*0.08));cx.lineWidth=1.3-s*0.1;cx.lineCap='round';cx.stroke();
      if(s>0&&sr()>0.25)jns.push({x:nx2,y:ny2,sz:1.2+sr()*2.5});
      px=nx2;py=ny2;ca+=sr()*0.6-0.3;}}
  for(const j of jns){const jg=cx.createRadialGradient(j.x,j.y,0,j.x,j.y,j.sz*3);
    jg.addColorStop(0,rga(h,0.8));jg.addColorStop(0.3,rga(b,0.25));jg.addColorStop(1,rga(b,0));
    cx.fillStyle=jg;cx.beginPath();cx.arc(j.x,j.y,j.sz*3,0,TAU);cx.fill();}}}
];

// ═══ DRAW: MEMBRANE ═══
function drawMem(ctx,d,hull){
  if(hull.length<3) return;
  const widths=[18,8,3.5,1.0].map(w => w * mods.memThickness);
  const alphas=[0.035,0.065,0.11,0.32].map(a => a * mods.memOpacity);
  const mc=ltn(gen.glow,30);
  for(let pass=0;pass<4;pass++){
    traceSmoothedHull(ctx,hull);
    ctx.strokeStyle=rga(mc,alphas[pass]);
    ctx.lineWidth=widths[pass];
    ctx.lineJoin='round';ctx.lineCap='round';ctx.stroke();
  }
}

// ═══ DRAW: GLOW ═══
function drawGlow(ctx,d,prims){
  for(const p of prims){
    // Apply shadow saturation shift
    let pc = p.rgb;
    if (mods.satShift > 0) pc = sat(pc, 1 + mods.satShift * 1.5);
    const str=p.tv*GSC[stg]*mods.glowIntensity;
    if(str<0.03) continue;
    const sc=SSC[stg];
    const nodeR=p.rd*sc;
    const glowR=(oR*2.5+p.tv*oR*2.0)*mods.glowRadius;
    const g=ctx.createRadialGradient(p.x,p.y,nodeR*0.3,p.x,p.y,glowR);
    g.addColorStop(0,rga(pc,0.40*str));
    g.addColorStop(0.05,rga(pc,0.32*str));
    g.addColorStop(0.12,rga(pc,0.22*str));
    g.addColorStop(0.25,rga(pc,0.13*str));
    g.addColorStop(0.45,rga(pc,0.06*str));
    g.addColorStop(0.7,rga(pc,0.025*str));
    g.addColorStop(1,rga(pc,0));
    ctx.fillStyle=g;ctx.fillRect(0,0,CW,CH);
  }
}

function drawAIFade(ctx,d){
  const bg=d?'5,10,24':'240,242,245';
  const vR=Math.max(CW,CH)*0.8;
  const g=ctx.createRadialGradient(CX,CY,vR*0.5,CX,CY,vR);
  g.addColorStop(0,`rgba(${bg},0)`);
  g.addColorStop(0.7,`rgba(${bg},0)`);
  g.addColorStop(1,`rgba(${bg},0.3)`);
  ctx.fillStyle=g;ctx.fillRect(0,0,CW,CH);
}

function drawBody(ctx,prims,d,hull){
  if(hull.length<3) return;
  let maxR=0;
  for(const h of hull){const d2=dst(h.x,h.y,CX,CY);if(d2>maxR)maxR=d2;}
  maxR=Math.max(maxR,50);
  const baseCol=ltn(gen.glow,15);
  const bg=ctx.createRadialGradient(CX,CY,0,CX,CY,maxR);
  bg.addColorStop(0,rga(baseCol,0.12));bg.addColorStop(0.6,rga(baseCol,0.08));bg.addColorStop(1,rga(baseCol,0.04));
  ctx.fillStyle=bg;ctx.fillRect(0,0,CW,CH);
  for(const p of prims){
    const pc=p.rgb, strength=p.tv*0.14;
    const r=maxR*0.65;
    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
    g.addColorStop(0,rga(pc,strength));g.addColorStop(0.4,rga(pc,strength*0.4));g.addColorStop(1,rga(pc,0));
    ctx.fillStyle=g;ctx.fillRect(0,0,CW,CH);
  }
}

function drawNeural(ctx,prims,d){
  const sr=m32(gen.s+9999);
  for(let i=0;i<prims.length;i++){
    for(let j=i+1;j<prims.length;j++){
      const a=prims[i],b=prims[j];
      const col=bl([a.rgb,b.rgb],[0.5,0.5]);
      const bc=ltn(col,60);
      const count=3+Math.floor((a.tv+b.tv)*2);
      for(let f=0;f<count;f++){
        const spread=(f/(count-1||1)-0.5)*0.6;
        const dx=b.x-a.x, dy=b.y-a.y, len=Math.sqrt(dx*dx+dy*dy)||1;
        const nx=-dy/len, ny=dx/len;
        const off=spread*oR*0.08;
        const mx=(a.x+b.x)/2+nx*off, my=(a.y+b.y)/2+ny*off;
        ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(mx,my,b.x,b.y);
        ctx.strokeStyle=rga(bc,0.08);ctx.lineWidth=0.4+sr()*0.5;ctx.stroke();
      }
    }
  }
  const r2=m32(gen.s+1111);
  const dotCount=20+stg*12;
  let maxR=0;
  for(const h of hullPts){const d2=dst(h.x,h.y,CX,CY);if(d2>maxR)maxR=d2;}
  maxR=Math.max(maxR,50);
  for(let i=0;i<dotCount;i++){
    const a=r2()*TAU,dd=maxR*(0.1+r2()*0.35);
    const px=CX+Math.cos(a)*dd,py=CY+Math.sin(a)*dd;
    const dists=prims.map(p=>({p,d:dst(px,py,p.x,p.y)})).sort((a,b)=>a.d-b.d);
    if(dists.length<2) continue;
    const c=bl([dists[0].p.rgb,dists[1].p.rgb],[0.6,0.4]);
    const bc=ltn(c,70);
    const sz=0.8+r2()*1.5;
    const g=ctx.createRadialGradient(px,py,0,px,py,sz*2.5);
    g.addColorStop(0,rga(bc,0.4));g.addColorStop(0.4,rga(bc,0.1));g.addColorStop(1,rga(bc,0));
    ctx.fillStyle=g;ctx.beginPath();ctx.arc(px,py,sz*2.5,0,TAU);ctx.fill();
  }
}

// ═══ MAIN RENDER ═══
function render(ts){
  const t=(ts-t0)/1000, dt=tL?Math.min((ts-tL)/1000,0.05):0.016; tL=ts;
  const d=thm==='dark', sc=SSC[stg];

  cvs.width=CW; cvs.height=CH;
  ctx.fillStyle=d?'#050A18':'#F0F2F5'; ctx.fillRect(0,0,CW,CH);

  // Light mode dark field
  if(!d){
    const vR=Math.max(CW,CH)*0.7;
    const df=ctx.createRadialGradient(CX,CY,0,CX,CY,vR);
    df.addColorStop(0,   'rgba(8,12,28,0.92)');
    df.addColorStop(0.15,'rgba(8,12,28,0.88)');
    df.addColorStop(0.30,'rgba(10,15,32,0.80)');
    df.addColorStop(0.45,'rgba(12,18,38,0.65)');
    df.addColorStop(0.58,'rgba(15,22,42,0.42)');
    df.addColorStop(0.70,'rgba(20,28,50,0.22)');
    df.addColorStop(0.82,'rgba(30,40,60,0.08)');
    df.addColorStop(0.92,'rgba(40,50,70,0.02)');
    df.addColorStop(1,   'rgba(240,242,245,0)');
    ctx.fillStyle=df;ctx.fillRect(0,0,CW,CH);
  }

  updPhys(actN,t);
  updPul(puls,dt);

  const prims=actN.filter(n=>n.tp==='p');

  drawGlow(ctx,d,prims);
  if(ent==='human') drawMem(ctx,d,hullPts);
  else drawAIFade(ctx,d);

  ctx.save();
  if(ent==='human' && hullPts.length>=3){
    traceSmoothedHull(ctx,hullPts);ctx.clip();
  }
  if(ent==='human') drawBody(ctx,prims,d,hullPts);
  drawNeural(ctx,prims,d);

  // Tissue connections
  for(const c of cons){
    const a=actN[c.a],b=actN[c.b]; if(!a||!b)continue;
    const mid=cMid(a,b), col=c.col;
    if(c.isPP){
      ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(mid.x,mid.y,b.x,b.y);
      ctx.strokeStyle=rga(col,0.04+c.str*0.02);ctx.lineWidth=22+c.str*12;ctx.lineCap='round';ctx.stroke();
    }
    ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(mid.x,mid.y,b.x,b.y);
    ctx.strokeStyle=rga(col,0.05+c.str*0.025);ctx.lineWidth=6+c.str*4;ctx.lineCap='round';ctx.stroke();
    ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(mid.x,mid.y,b.x,b.y);
    ctx.strokeStyle=rga(ltn(col,25),0.35+c.str*0.12);ctx.lineWidth=0.5+c.str*0.7;ctx.stroke();
  }

  // Energy pulses
  for(const p of puls){
    const a=actN[p.a],b=actN[p.b]; if(!a||!b)continue;
    const mid=cMid(a,b),pr=p.p,mt=1-pr;
    const px=mt*mt*a.x+2*mt*pr*mid.x+pr*pr*b.x, py=mt*mt*a.y+2*mt*pr*mid.y+pr*pr*b.y;
    const gr=ctx.createRadialGradient(px,py,0,px,py,p.sz*3);
    gr.addColorStop(0,rga(p.col,0.6));gr.addColorStop(0.3,rga(p.col,0.18));gr.addColorStop(1,rga(p.col,0));
    ctx.fillStyle=gr;ctx.beginPath();ctx.arc(px,py,p.sz*3,0,TAU);ctx.fill();
  }

  // Nodes
  const sorted=[...actN].sort((a,b)=>a.dp-b.dp);
  for(const n of sorted){
    const r=n.rd*sc*(1+0.02*Math.sin(n.bp+t*0.3)+Math.sin(t*0.12*mods.breathRate)*0.003*mods.breathAmp);
    let col = n.rgb;
    if (mods.satShift > 0) col = sat(col, 1 + mods.satShift * 1.0);
    if(n.tp==='p'){
      const hr=ctx.createRadialGradient(n.x,n.y,r*0.6,n.x,n.y,r*2.5);
      hr.addColorStop(0,rga(col,0.2));hr.addColorStop(0.4,rga(col,0.08));hr.addColorStop(1,rga(col,0));
      ctx.fillStyle=hr;ctx.beginPath();ctx.arc(n.x,n.y,r*2.5,0,TAU);ctx.fill();
      blobP(ctx,n.x,n.y,r,n.sd,t);ctx.fillStyle=rga(drk(col,55),0.88);ctx.fill();
      ctx.save();blobP(ctx,n.x,n.y,r,n.sd,t);ctx.clip();INT[n.iIdx].fn(ctx,n,r,col,d,t);ctx.restore();
      blobP(ctx,n.x,n.y,r,n.sd,t);ctx.strokeStyle=rga(col,0.12);ctx.lineWidth=5;ctx.stroke();
      blobP(ctx,n.x,n.y,r,n.sd,t);ctx.strokeStyle=rga(col,0.28);ctx.lineWidth=2;ctx.stroke();
      blobP(ctx,n.x,n.y,r,n.sd,t);ctx.strokeStyle=rga(ltn(col,40),0.65);ctx.lineWidth=0.7;ctx.stroke();
    } else if(n.tp==='c'){
      const g2=ctx.createRadialGradient(n.x,n.y,0,n.x,n.y,r*4);
      g2.addColorStop(0,rga(col,0.28));g2.addColorStop(0.3,rga(col,0.1));g2.addColorStop(1,rga(col,0));
      ctx.fillStyle=g2;ctx.beginPath();ctx.arc(n.x,n.y,r*4,0,TAU);ctx.fill();
      ctx.fillStyle=rga(drk(col,25),0.82);ctx.beginPath();ctx.arc(n.x,n.y,r,0,TAU);ctx.fill();
      ctx.fillStyle=rga(ltn(col,80),0.85);ctx.beginPath();ctx.arc(n.x,n.y,r*0.35,0,TAU);ctx.fill();
      ctx.strokeStyle=rga(col,0.5);ctx.lineWidth=0.4;ctx.beginPath();ctx.arc(n.x,n.y,r,0,TAU);ctx.stroke();
    } else {
      const g3=ctx.createRadialGradient(n.x,n.y,0,n.x,n.y,r*3);
      g3.addColorStop(0,rga(col,0.28));g3.addColorStop(0.3,rga(col,0.08));g3.addColorStop(1,rga(col,0));
      ctx.fillStyle=g3;ctx.beginPath();ctx.arc(n.x,n.y,r*3,0,TAU);ctx.fill();
      ctx.fillStyle=rga(col,0.7);ctx.beginPath();ctx.arc(n.x,n.y,r,0,TAU);ctx.fill();
    }
  }

  ctx.restore();
  requestAnimationFrame(render);
}

// ═══ CONTROLS ═══
function sS(i){stg=i;scores.depth=i===0?0:i===1?1:i===2?2:4;
  for(let j=0;j<4;j++) document.getElementById('s'+j).classList.toggle('on',j===i);
  updateSlider('depth', scores.depth);
  rebuild();}
function sE(m){ent=m;document.getElementById('eh').classList.toggle('on',m==='human');document.getElementById('ea').classList.toggle('on',m==='ai');}
function sT(t){thm=t;document.getElementById('td').classList.toggle('on',t==='dark');document.getElementById('tl').classList.toggle('on',t==='light');}

function fullRebuild(){
  deriveModifiers();
  gen=mkGen();
  allN=mkNodes(gen);
  actN=filt(allN,stg);
  cons=mkCon(actN);
  puls=mkPul(cons,gen.s);
  updInfo();
  updStats();
}

function rebuild(){
  deriveModifiers();
  actN=filt(allN,stg);
  cons=mkCon(actN);
  puls=mkPul(cons,gen.s);
  updStats();
}

// Soft rebuild — only recompute genome + nodes when Big Five changes
function onScoreChange(section) {
  deriveModifiers();
  if (section === 'bigFive') {
    gen = mkGen();
    allN = mkNodes(gen);
    actN = filt(allN, stg);
    cons = mkCon(actN);
    puls = mkPul(cons, gen.s);
    updInfo();
  } else if (section === 'depth') {
    actN = filt(allN, stg);
    cons = mkCon(actN);
    puls = mkPul(cons, gen.s);
  } else if (section === 'attachment' || section === 'connDensity') {
    cons = mkCon(actN);
    puls = mkPul(cons, gen.s);
  }
  // motion/glow/membrane/shadow changes are picked up in render loop via mods
  updStats();
}

function updInfo(){
  document.getElementById('info').innerHTML=TK.map(k=>{
    const c=TR[k].base,v=gen.tv[k];
    return`<span class="trait"><span class="dot" style="background:rgb(${c})"></span>${TR[k].l} ${(v*100).toFixed(0)}</span>`;
  }).join('');
}

function updStats(){
  const s = scores;
  const attachStyle = s.attachment.anxiety < 2.5 && s.attachment.avoidance < 2.5 ? 'Secure' :
    s.attachment.anxiety >= 2.5 && s.attachment.avoidance < 2.5 ? 'Anxious' :
    s.attachment.anxiety < 2.5 && s.attachment.avoidance >= 2.5 ? 'Avoidant' : 'Fearful';
  document.getElementById('stats').innerHTML = [
    `Nodes: ${actN.length} (${actN.filter(n=>n.tp==='p').length}p ${actN.filter(n=>n.tp==='c').length}c ${actN.filter(n=>n.tp==='a').length}a)`,
    `Connections: ${cons.length} | Pulses: ${puls.length}`,
    `Stage: ${stg} | Attach: ${attachStyle}`,
    `Drift: ${mods.driftAmp.toFixed(2)} | Sway: ${mods.swayAmp.toFixed(2)} | Wiggle: ${mods.wiggleAmp.toFixed(2)}`,
  ].join('<br>');
}

// ═══ SIDEBAR UI ═══
function toggleSection(id){
  document.getElementById(id).classList.toggle('collapsed');
}
function toggleSidebar(){
  document.body.classList.toggle('sidebar-hidden');
  document.getElementById('sidebarToggle').textContent =
    document.body.classList.contains('sidebar-hidden') ? '▶' : '◀';
  resize();
}

// Slider creation helper
const sliderEls = {};
function mkSlider(containerId, key, label, min, max, step, value, onChange) {
  const body = document.getElementById(containerId);
  const row = document.createElement('div');
  row.className = 'slider-row';

  const lbl = document.createElement('span');
  lbl.className = 'slider-label';
  lbl.textContent = label;

  const wrap = document.createElement('div');
  wrap.className = 'slider-wrap';

  const input = document.createElement('input');
  input.type = 'range';
  input.min = min; input.max = max; input.step = step;
  input.value = value;

  const val = document.createElement('span');
  val.className = 'slider-value';
  val.textContent = Number(value).toFixed(step < 1 ? (step < 0.1 ? 2 : 1) : 0);

  input.addEventListener('input', () => {
    const v = parseFloat(input.value);
    val.textContent = v.toFixed(step < 1 ? (step < 0.1 ? 2 : 1) : 0);
    onChange(v);
  });

  wrap.appendChild(input);
  row.appendChild(lbl);
  row.appendChild(wrap);
  row.appendChild(val);
  body.appendChild(row);

  sliderEls[key] = { input, val, step };
}

function updateSlider(key, value) {
  const el = sliderEls[key];
  if (!el) return;
  el.input.value = value;
  el.val.textContent = Number(value).toFixed(el.step < 1 ? (el.step < 0.1 ? 2 : 1) : 0);
}

function buildUI() {
  // Big Five
  for (const k of TK) {
    mkSlider('body-bigfive', 'bf_'+k, TR[k].l, 0, 100, 1, scores.bigFive[k], v => {
      scores.bigFive[k] = v; onScoreChange('bigFive');
    });
  }

  // Shadow
  const shadowNames = {M:'Machiavellian', N:'Narcissism', P:'Psychopathy'};
  for (const k of ['M','N','P']) {
    mkSlider('body-shadow', 'sh_'+k, shadowNames[k], 0, 100, 1, scores.shadow[k], v => {
      scores.shadow[k] = v; onScoreChange('shadow');
    });
  }

  // Attachment
  mkSlider('body-attach', 'at_anx', 'Anxiety', 0, 5, 0.1, scores.attachment.anxiety, v => {
    scores.attachment.anxiety = v; onScoreChange('attachment');
  });
  mkSlider('body-attach', 'at_avd', 'Avoidance', 0, 5, 0.1, scores.attachment.avoidance, v => {
    scores.attachment.avoidance = v; onScoreChange('attachment');
  });

  // Risk
  const riskNames = {financial:'Financial', social:'Social', physical:'Physical', ethical:'Ethical'};
  for (const k of ['financial','social','physical','ethical']) {
    mkSlider('body-risk', 'rk_'+k, riskNames[k], 0, 100, 1, scores.risk[k], v => {
      scores.risk[k] = v; onScoreChange('risk');
    });
  }

  // Chronotype
  mkSlider('body-chrono', 'chrono', 'Morningness', 0, 100, 1, scores.chronotype, v => {
    scores.chronotype = v; onScoreChange('chronotype');
  });

  // ADHD
  mkSlider('body-adhd', 'adhd', 'Indicators', 0, 6, 1, scores.adhd, v => {
    scores.adhd = v; onScoreChange('adhd');
  });

  // Depth
  mkSlider('body-adhd', 'depth', 'Assess depth', 0, 20, 1, scores.depth, v => {
    scores.depth = v; onScoreChange('depth');
  });

  // Motion (derived, but overridable)
  const motionSliders = [
    ['driftAmp',    'Drift amp',   0, 3,   0.05, mods.driftAmp],
    ['driftSpeed',  'Drift spd',   0, 3,   0.05, mods.driftSpeed],
    ['swayAmp',     'Sway amp',    0, 3,   0.05, mods.swayAmp],
    ['wiggleAmp',   'Wiggle amp',  0, 4,   0.05, mods.wiggleAmp],
    ['wiggleSpeed', 'Wiggle spd',  0, 3,   0.05, mods.wiggleSpeed],
    ['breathRate',  'Breath rate', 0, 3,   0.05, mods.breathRate],
    ['breathAmp',   'Breath amp',  0, 3,   0.05, mods.breathAmp],
    ['pulseSpeed',  'Pulse spd',   0, 3,   0.05, mods.pulseSpeed],
  ];
  for (const [key, label, min, max, step, val] of motionSliders) {
    mkSlider('body-motion', 'mo_'+key, label, min, max, step, val, v => {
      modsOverride[key] = true; mods[key] = v;
      if (key === 'pulseSpeed' || key === 'connDensity') onScoreChange('connDensity');
    });
  }

  // Glow
  mkSlider('body-glow', 'gl_radius', 'Radius', 0.1, 3, 0.05, mods.glowRadius, v => {
    modsOverride.glowRadius = true; mods.glowRadius = v;
  });
  mkSlider('body-glow', 'gl_intensity', 'Intensity', 0, 3, 0.05, mods.glowIntensity, v => {
    modsOverride.glowIntensity = true; mods.glowIntensity = v;
  });
  mkSlider('body-glow', 'gl_satShift', 'Sat shift', 0, 1, 0.02, mods.satShift, v => {
    modsOverride.satShift = true; mods.satShift = v;
  });
  mkSlider('body-glow', 'gl_edgeSharp', 'Edge sharp', 0, 1, 0.02, mods.edgeSharp, v => {
    modsOverride.edgeSharp = true; mods.edgeSharp = v;
  });

  // Membrane
  mkSlider('body-membrane', 'mm_opacity', 'Opacity', 0, 3, 0.05, mods.memOpacity, v => {
    modsOverride.memOpacity = true; mods.memOpacity = v;
  });
  mkSlider('body-membrane', 'mm_thickness', 'Thickness', 0, 3, 0.05, mods.memThickness, v => {
    modsOverride.memThickness = true; mods.memThickness = v;
  });
  mkSlider('body-membrane', 'mm_connDensity', 'Conn density', 0.2, 3, 0.05, mods.connDensity, v => {
    modsOverride.connDensity = true; mods.connDensity = v; onScoreChange('connDensity');
  });
  mkSlider('body-membrane', 'mm_pulseIrr', 'Pulse chaos', 0, 1, 0.02, mods.connPulseIrr, v => {
    modsOverride.connPulseIrr = true; mods.connPulseIrr = v; onScoreChange('connDensity');
  });

  // Global
  mkSlider('body-global', 'g_seed', 'Seed', 1, 99999, 1, 12345, v => {
    // Override seed for exploration
    gen.s = v;
    const r = m32(v);
    const iord = [0,1,2,3,4,5].sort(() => r() - 0.5);
    for (let i=0;i<5;i++) gen.ints[TK[i]] = iord[i];
    allN = mkNodes(gen);
    rebuild();
  });
}

// ═══ PRESETS ═══
const PRESETS = {
  'Balanced': {
    bigFive: {O:55,C:55,E:55,A:55,N:55}, shadow:{M:20,N:20,P:15},
    attachment:{anxiety:1.5,avoidance:1.5}, risk:{financial:40,social:40,physical:40,ethical:40},
    chronotype:50, adhd:1, depth:4
  },
  'High Extravert': {
    bigFive: {O:70,C:45,E:95,A:75,N:25}, shadow:{M:15,N:30,P:10},
    attachment:{anxiety:1.0,avoidance:0.8}, risk:{financial:55,social:70,physical:50,ethical:40},
    chronotype:65, adhd:1, depth:6
  },
  'Deep Thinker': {
    bigFive: {O:92,C:78,E:20,A:50,N:55}, shadow:{M:25,N:15,P:10},
    attachment:{anxiety:2.5,avoidance:2.0}, risk:{financial:30,social:20,physical:15,ethical:25},
    chronotype:30, adhd:3, depth:8
  },
  'Dark Triad': {
    bigFive: {O:60,C:70,E:65,A:15,N:35}, shadow:{M:88,N:92,P:78},
    attachment:{anxiety:1.5,avoidance:4.0}, risk:{financial:85,social:75,physical:70,ethical:90},
    chronotype:35, adhd:2, depth:5
  },
  'Anxious Attacher': {
    bigFive: {O:55,C:40,E:60,A:85,N:80}, shadow:{M:10,N:10,P:5},
    attachment:{anxiety:4.5,avoidance:1.0}, risk:{financial:20,social:25,physical:15,ethical:15},
    chronotype:45, adhd:2, depth:4
  },
  'Risk Taker': {
    bigFive: {O:80,C:30,E:85,A:40,N:30}, shadow:{M:45,N:50,P:35},
    attachment:{anxiety:1.5,avoidance:2.5}, risk:{financial:90,social:85,physical:95,ethical:70},
    chronotype:60, adhd:4, depth:3
  },
  'Minimalist': {
    bigFive: {O:25,C:90,E:15,A:65,N:10}, shadow:{M:5,N:5,P:3},
    attachment:{anxiety:0.5,avoidance:1.0}, risk:{financial:10,social:15,physical:10,ethical:5},
    chronotype:80, adhd:0, depth:2
  },
  'Hyperfocus': {
    bigFive: {O:85,C:35,E:50,A:45,N:60}, shadow:{M:20,N:25,P:10},
    attachment:{anxiety:2.5,avoidance:1.5}, risk:{financial:50,social:45,physical:40,ethical:30},
    chronotype:25, adhd:6, depth:5
  },
  'New User': {
    bigFive: {O:50,C:50,E:50,A:50,N:50}, shadow:{M:25,N:25,P:25},
    attachment:{anxiety:2.5,avoidance:2.5}, risk:{financial:50,social:50,physical:50,ethical:50},
    chronotype:50, adhd:1, depth:0
  },
  'Random': null // special handler
};

function loadPreset(name) {
  // Clear manual overrides
  modsOverride = {};

  if (name === 'Random') {
    scores.bigFive = {O:R(100),C:R(100),E:R(100),A:R(100),N:R(100)};
    scores.shadow = {M:R(100),N:R(100),P:R(100)};
    scores.attachment = {anxiety:Math.random()*5,avoidance:Math.random()*5};
    scores.risk = {financial:R(100),social:R(100),physical:R(100),ethical:R(100)};
    scores.chronotype = R(100);
    scores.adhd = R(6);
    scores.depth = R(20);
  } else {
    const p = PRESETS[name];
    scores.bigFive = {...p.bigFive};
    scores.shadow = {...p.shadow};
    scores.attachment = {...p.attachment};
    scores.risk = {...p.risk};
    scores.chronotype = p.chronotype;
    scores.adhd = p.adhd;
    scores.depth = p.depth;
  }

  // Update all sliders
  syncSlidersToScores();
  fullRebuild();

  // Highlight active preset
  document.querySelectorAll('.presets button').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
}

function R(max) { return Math.floor(Math.random() * (max + 1)); }

function syncSlidersToScores() {
  for (const k of TK) updateSlider('bf_'+k, scores.bigFive[k]);
  for (const k of ['M','N','P']) updateSlider('sh_'+k, scores.shadow[k]);
  updateSlider('at_anx', scores.attachment.anxiety);
  updateSlider('at_avd', scores.attachment.avoidance);
  for (const k of ['financial','social','physical','ethical']) updateSlider('rk_'+k, scores.risk[k]);
  updateSlider('chrono', scores.chronotype);
  updateSlider('adhd', scores.adhd);
  updateSlider('depth', scores.depth);

  // Re-derive and sync motion sliders
  deriveModifiers();
  for (const key of ['driftAmp','driftSpeed','swayAmp','wiggleAmp','wiggleSpeed','breathRate','breathAmp','pulseSpeed']) {
    updateSlider('mo_'+key, mods[key]);
  }
  updateSlider('gl_radius', mods.glowRadius);
  updateSlider('gl_intensity', mods.glowIntensity);
  updateSlider('gl_satShift', mods.satShift);
  updateSlider('gl_edgeSharp', mods.edgeSharp);
  updateSlider('mm_opacity', mods.memOpacity);
  updateSlider('mm_thickness', mods.memThickness);
  updateSlider('mm_connDensity', mods.connDensity);
  updateSlider('mm_pulseIrr', mods.connPulseIrr);
}

function randomizeSection(section) {
  if (section === 'bigFive') {
    for (const k of TK) scores.bigFive[k] = R(100);
  } else if (section === 'shadow') {
    for (const k of ['M','N','P']) scores.shadow[k] = R(100);
  } else if (section === 'attachment') {
    scores.attachment.anxiety = Math.random() * 5;
    scores.attachment.avoidance = Math.random() * 5;
  } else if (section === 'risk') {
    for (const k of ['financial','social','physical','ethical']) scores.risk[k] = R(100);
  } else if (section === 'chronotype') {
    scores.chronotype = R(100);
  } else if (section === 'adhd') {
    scores.adhd = R(6);
  }
  syncSlidersToScores();
  fullRebuild();
}

function resetMotion() {
  for (const key of ['driftAmp','driftSpeed','swayAmp','wiggleAmp','wiggleSpeed','breathRate','breathAmp','pulseSpeed']) {
    delete modsOverride[key];
  }
  deriveModifiers();
  syncSlidersToScores();
}
function resetGlow() {
  for (const key of ['glowRadius','glowIntensity','satShift','edgeSharp']) {
    delete modsOverride[key];
    if (key === 'glowRadius' || key === 'glowIntensity') mods[key] = 1.0;
  }
  deriveModifiers();
  syncSlidersToScores();
}
function resetMembrane() {
  for (const key of ['memOpacity','memThickness','connDensity','connPulseIrr']) {
    delete modsOverride[key];
    if (key === 'memOpacity' || key === 'memThickness') mods[key] = 1.0;
  }
  deriveModifiers();
  syncSlidersToScores();
  onScoreChange('connDensity');
}

function buildPresets() {
  const container = document.getElementById('presets');
  for (const name of Object.keys(PRESETS)) {
    const btn = document.createElement('button');
    btn.textContent = name;
    btn.onclick = () => loadPreset(name);
    container.appendChild(btn);
  }
}

// ═══ RESIZE ═══
function resize(){
  const area = document.querySelector('.viz-area');
  CW = cvs.width = area.clientWidth;
  CH = cvs.height = area.clientHeight;
  CX = CW/2; CY = CH/2;
  oR = Math.min(CW, CH) * 0.38;
  if (gen) { allN = mkNodes(gen); rebuild(); }
}

// ═══ INIT ═══
cvs = document.getElementById('c');
ctx = cvs.getContext('2d');

buildUI();
buildPresets();

resize();
window.addEventListener('resize', resize);
t0 = performance.now();

deriveModifiers();
gen = mkGen();
allN = mkNodes(gen);
actN = filt(allN, stg);
cons = mkCon(actN);
puls = mkPul(cons, gen.s);
updInfo();
updStats();
requestAnimationFrame(render);

</script>
</body>
</html>
