<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aura Viz — Session v7 — Combination Arena</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #030712; color: #e2e8f0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px 10px; }
  h1 { font-size: 16px; font-weight: 500; letter-spacing: 2px; text-transform: uppercase; color: #94a3b8; margin-bottom: 12px; }
  .controls { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; justify-content: center; }
  .controls button { background: #1e293b; border: 1px solid #334155; color: #94a3b8; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
  .controls button:hover { background: #334155; color: #e2e8f0; }
  .controls button.active { background: #4ECDC4; color: #030712; border-color: #4ECDC4; font-weight: 600; }
  .divider { width: 1px; background: #334155; margin: 0 4px; }
  .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; max-width: 960px; width: 100%; }
  .card { background: #0a1020; border: 1px solid #1e293b; border-radius: 8px; padding: 8px; display: flex; flex-direction: column; align-items: center; }
  .card canvas { border-radius: 4px; width: 280px; height: 280px; }
  .card-label { font-size: 11px; color: #64748b; margin-top: 6px; letter-spacing: 1px; text-align: center; }
  .card-label span { color: #94a3b8; font-weight: 600; }
  .card-label .sub { display: block; font-size: 9px; color: #475569; margin-top: 2px; letter-spacing: 0.5px; }
</style>
</head>
<body>
<h1>Aura Organism — v7 Combination Arena</h1>
<div class="controls">
  <button onclick="setTier('seed')" id="btn-seed">Seed</button>
  <button onclick="setTier('young')" id="btn-young">Young</button>
  <button onclick="setTier('full')" id="btn-full" class="active">Full</button>
  <button onclick="setTier('random')" id="btn-random">Random</button>
  <div class="divider"></div>
  <button onclick="setMode('human')" id="btn-human" class="active">Human</button>
  <button onclick="setMode('ai')" id="btn-ai">AI</button>
</div>
<div class="grid" id="grid"></div>

<script>
// ─── DATA ───
const NEURON_MAP = {
  N: { label: 'Openness', color: '#4ECDC4' },
  E: { label: 'Conscientiousness', color: '#45B7D1' },
  A: { label: 'Extraversion', color: '#96E6A1' },
  O: { label: 'Agreeableness', color: '#DDA0DD' },
  C: { label: 'Neuroticism', color: '#F7DC6F' }
};
const ASSESS_MAP = {
  a1: { label: 'Curiosity', color: '#7FDBCA', link: 'N' },
  a2: { label: 'Imagination', color: '#6BC5B0', link: 'N' },
  a3: { label: 'Discipline', color: '#5DADE2', link: 'E' },
  a4: { label: 'Reliability', color: '#3498DB', link: 'E' },
  a5: { label: 'Warmth', color: '#82E0AA', link: 'A' },
  a6: { label: 'Assertiveness', color: '#58D68D', link: 'A' },
  a7: { label: 'Empathy', color: '#C39BD3', link: 'O' },
  a8: { label: 'Trust', color: '#AF7AC5', link: 'O' },
  a9: { label: 'Resilience', color: '#F9E154', link: 'C' },
  a10: { label: 'Calm', color: '#F4D03F', link: 'C' }
};

const CARD_DEFS = [
  { id: 'A', name: 'Pure Web + Gentle Curves', sub: 'Minimal elegance' },
  { id: 'B', name: 'Web + Undulating Tendrils', sub: 'Deep sea organism' },
  { id: 'C', name: 'Web + Neural Pulses', sub: 'Quiet brain, occasional thought' },
  { id: 'D', name: 'Web + Particle Dust', sub: 'Web in luminous fog' },
  { id: 'E', name: 'Tendrils + Pulses', sub: 'Bioluminescent nervous system' },
  { id: 'F', name: 'Web + Interior Glow Zones', sub: 'Web over aurora' },
  { id: 'G', name: 'Full Mix', sub: 'Tendrils + Dust + Pulses' },
  { id: 'H', name: 'Web + Circuit Paths', sub: 'Organic meets digital' },
  { id: 'I', name: 'Tendrils + Glow Zones', sub: 'Most organic, least geometric' }
];

let currentTier = 'full';
let currentMode = 'human';
const canvases = {};
const DPR = window.devicePixelRatio || 1;
const CW = 280, CH = 280;
const CX = CW / 2, CY = CH / 2;

// ─── HELPERS ───
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return { r, g, b };
}
function rgba(hex, a) {
  const { r, g, b } = hexToRgb(hex);
  return `rgba(${r},${g},${b},${a})`;
}
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ─── NODE GENERATION ───
function generateNodes(tier) {
  const nodes = [];
  const primaries = Object.entries(NEURON_MAP);
  const angleStep = (Math.PI * 2) / primaries.length;
  primaries.forEach(([id, d], i) => {
    const angle = angleStep * i - Math.PI / 2;
    const r = 55;
    nodes.push({
      id, label: d.label, color: d.color, type: 'primary',
      x: CX + Math.cos(angle) * r, y: CY + Math.sin(angle) * r,
      bx: CX + Math.cos(angle) * r, by: CY + Math.sin(angle) * r,
      vx: 0, vy: 0,
      radius: 5.5, alpha: 0, birthTime: 0,
      driftPhase: Math.random() * Math.PI * 2,
      driftSpeed: 4 + Math.random() * 4, driftAmp: 2 + Math.random() * 2
    });
  });
  if (tier === 'seed') return nodes;

  // Companions — 2 per primary
  primaries.forEach(([pid], pi) => {
    for (let j = 0; j < 2; j++) {
      const angle = angleStep * pi - Math.PI / 2 + (j === 0 ? -0.45 : 0.45);
      const r = 85;
      const id = `comp_${pid}_${j}`;
      nodes.push({
        id, label: '', color: NEURON_MAP[pid].color, type: 'companion', parent: pid,
        x: CX + Math.cos(angle) * r, y: CY + Math.sin(angle) * r,
        bx: CX + Math.cos(angle) * r, by: CY + Math.sin(angle) * r,
        vx: 0, vy: 0,
        radius: 3.5, alpha: 0, birthTime: 0.3,
        driftPhase: Math.random() * Math.PI * 2,
        driftSpeed: 4 + Math.random() * 3, driftAmp: 2 + Math.random() * 2
      });
    }
  });

  // Satellites — 1 per primary
  primaries.forEach(([pid], pi) => {
    const angle = angleStep * pi - Math.PI / 2 + 0.2;
    const r = 105;
    const id = `sat_${pid}`;
    nodes.push({
      id, label: '', color: NEURON_MAP[pid].color, type: 'satellite', parent: pid,
      x: CX + Math.cos(angle) * r, y: CY + Math.sin(angle) * r,
      bx: CX + Math.cos(angle) * r, by: CY + Math.sin(angle) * r,
      vx: 0, vy: 0,
      radius: 2.5, alpha: 0, birthTime: 0.5,
      driftPhase: Math.random() * Math.PI * 2,
      driftSpeed: 5 + Math.random() * 3, driftAmp: 1.5 + Math.random() * 2
    });
  });

  if (tier !== 'full') return nodes;

  // Assessment nodes
  Object.entries(ASSESS_MAP).forEach(([id, d], i) => {
    const parent = nodes.find(n => n.id === d.link);
    const offset = (i % 2 === 0 ? -1 : 1) * (16 + Math.random() * 12);
    const px = parent.bx + offset + (Math.random() - 0.5) * 18;
    const py = parent.by + offset + (Math.random() - 0.5) * 18;
    nodes.push({
      id, label: d.label, color: d.color, type: 'assess', parent: d.link,
      x: px, y: py, bx: px, by: py, vx: 0, vy: 0,
      radius: 2, alpha: 0, birthTime: 0.6 + Math.random() * 0.3,
      driftPhase: Math.random() * Math.PI * 2,
      driftSpeed: 4 + Math.random() * 4, driftAmp: 1.5 + Math.random() * 1.5
    });
  });
  return nodes;
}

// ─── CONNECTIONS ───
function generateConnections(nodes) {
  const conns = [];
  const ids = new Set(nodes.map(n => n.id));
  const primKeys = Object.keys(NEURON_MAP);
  // Primary ring
  for (let i = 0; i < primKeys.length; i++) {
    conns.push({ from: primKeys[i], to: primKeys[(i + 1) % primKeys.length], alpha: 1 });
  }
  // Star cross-links between primaries
  conns.push({ from: primKeys[0], to: primKeys[2], alpha: 0.6 });
  conns.push({ from: primKeys[1], to: primKeys[3], alpha: 0.6 });
  // Parent links
  nodes.forEach(n => {
    if (n.parent && ids.has(n.parent)) {
      conns.push({ from: n.id, to: n.parent, alpha: 1 });
    }
  });
  // Cross-links for full tier
  if (nodes.length > 20) {
    conns.push({ from: 'a1', to: 'a3', alpha: 0.4 });
    conns.push({ from: 'a5', to: 'a7', alpha: 0.4 });
    conns.push({ from: 'a9', to: 'a1', alpha: 0.4 });
    conns.push({ from: 'a2', to: 'a8', alpha: 0.4 });
    conns.push({ from: 'a4', to: 'a10', alpha: 0.4 });
    conns.push({ from: 'a6', to: 'a2', alpha: 0.3 });
  }
  return conns.filter(c => ids.has(c.from) && ids.has(c.to));
}

// ─── CARD STATE ───
const cardStates = {};

function initCard(cardId) {
  const nodes = generateNodes(currentTier);
  const conns = generateConnections(nodes);
  const startTime = performance.now();
  const livingConns = conns.map(c => ({ ...c, visible: true, fadeAlpha: 1 }));
  const state = {
    nodes, conns, livingConns, startTime,
    particles: null, pulses: [], nextPulseTime: 0,
    nextConnEvent: 5000 + Math.random() * 5000,
    hullPhases: []
  };
  // Hull phases for undulating membrane
  for (let i = 0; i < 60; i++) {
    state.hullPhases.push({ phase: Math.random() * Math.PI * 2, period: 3 + Math.random() * 2 });
  }
  // Init particles for cards that need them
  if (cardId === 'D' || cardId === 'G') initParticles(state);
  // Init pulses for cards that need them
  if (cardId === 'C' || cardId === 'E' || cardId === 'G') {
    state.nextPulseTime = 2000 + Math.random() * 2000;
  }
  cardStates[cardId] = state;
}

function initParticles(state) {
  const count = 50;
  state.particles = [];
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * 110;
    state.particles.push({
      x: CX + Math.cos(angle) * r,
      y: CY + Math.sin(angle) * r,
      vx: (Math.random() - 0.5) * 0.2,
      vy: (Math.random() - 0.5) * 0.2,
      alpha: 0.03 + Math.random() * 0.03,
      color: Object.values(NEURON_MAP)[Math.floor(Math.random() * 5)].color
    });
  }
}

// ─── DRIFT & PHYSICS ───
function applyDrift(node, time) {
  const t = time / 1000;
  const dx = Math.sin(t / node.driftSpeed + node.driftPhase) * node.driftAmp;
  const dy = Math.cos(t / node.driftSpeed * 0.7 + node.driftPhase + 1) * node.driftAmp;
  node.x = node.bx + dx;
  node.y = node.by + dy;
}

function getNodeAlpha(node, elapsed) {
  const t = elapsed - node.birthTime * 1000;
  if (t < 0) return 0;
  return Math.min(1, t / 1000);
}

// ─── CONVEX HULL ───
function cross(O, A, B) {
  return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}
function convexHull(points) {
  if (points.length < 3) return points.slice();
  const sorted = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
  const lower = [];
  for (const p of sorted) {
    while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  const upper = [];
  for (let i = sorted.length - 1; i >= 0; i--) {
    const p = sorted[i];
    while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  return lower.concat(upper);
}

function expandHull(hull, pad) {
  // Expand hull outward by pad pixels
  const cx = hull.reduce((s,p) => s + p.x, 0) / hull.length;
  const cy = hull.reduce((s,p) => s + p.y, 0) / hull.length;
  return hull.map(p => {
    const dx = p.x - cx, dy = p.y - cy;
    const d = Math.hypot(dx, dy) || 1;
    return { x: p.x + (dx / d) * pad, y: p.y + (dy / d) * pad };
  });
}

function pointInHull(hull, px, py) {
  // Ray casting
  let inside = false;
  for (let i = 0, j = hull.length - 1; i < hull.length; j = i++) {
    const xi = hull[i].x, yi = hull[i].y, xj = hull[j].x, yj = hull[j].y;
    if ((yi > py) !== (yj > py) && px < (xj - xi) * (py - yi) / (yj - yi) + xi) inside = !inside;
  }
  return inside;
}

function clampToHull(hull, px, py) {
  if (pointInHull(hull, px, py)) return { x: px, y: py };
  // Find closest point on hull boundary
  let bestX = px, bestY = py, bestDist = Infinity;
  for (let i = 0; i < hull.length; i++) {
    const a = hull[i], b = hull[(i + 1) % hull.length];
    const dx = b.x - a.x, dy = b.y - a.y;
    const len2 = dx * dx + dy * dy;
    let t = len2 === 0 ? 0 : clamp(((px - a.x) * dx + (py - a.y) * dy) / len2, 0, 1);
    const cx = a.x + t * dx, cy = a.y + t * dy;
    const d = Math.hypot(px - cx, py - cy);
    if (d < bestDist) { bestDist = d; bestX = cx; bestY = cy; }
  }
  return { x: bestX, y: bestY };
}

// ─── BUBBLE MEMBRANE ───
function computeHull(nodes) {
  const pts = nodes.filter(n => n.alpha > 0.01).map(n => ({ x: n.x, y: n.y }));
  if (pts.length < 3) return null;
  return convexHull(pts);
}

function containNodes(nodes, hull) {
  if (!hull) return;
  const insetHull = expandHull(hull, -10);
  nodes.forEach(n => {
    if (n.alpha < 0.01) return;
    const clamped = clampToHull(insetHull, n.x, n.y);
    n.x = clamped.x;
    n.y = clamped.y;
  });
}

function getAvgColor(nodes) {
  let r = 0, g = 0, b = 0, count = 0;
  nodes.forEach(n => {
    if (n.alpha > 0.01) {
      const c = hexToRgb(n.color);
      r += c.r; g += c.g; b += c.b; count++;
    }
  });
  if (count === 0) return { r: 78, g: 205, b: 196 };
  return { r: Math.round(r/count), g: Math.round(g/count), b: Math.round(b/count) };
}

function drawMembrane(ctx, nodes, state, time, undulate) {
  const rawHull = computeHull(nodes);
  if (!rawHull || rawHull.length < 3) return rawHull;
  const hull = expandHull(rawHull, 25);
  const avg = getAvgColor(nodes);
  const t = time / 1000;

  // Smooth the hull into a curve with optional undulation
  ctx.save();
  const pts = hull.map((p, i) => {
    let ux = 0, uy = 0;
    if (undulate && state.hullPhases[i]) {
      const hp = state.hullPhases[i];
      const cx = hull.reduce((s,q) => s + q.x, 0) / hull.length;
      const cy = hull.reduce((s,q) => s + q.y, 0) / hull.length;
      const dx = p.x - cx, dy = p.y - cy;
      const d = Math.hypot(dx, dy) || 1;
      const amp = 3 + Math.sin(hp.phase) * 2;
      const wave = Math.sin(t / hp.period * Math.PI * 2 + hp.phase) * amp;
      ux = (dx / d) * wave;
      uy = (dy / d) * wave;
    }
    return { x: p.x + ux, y: p.y + uy };
  });

  // Draw smooth closed curve through hull points
  function drawSmoothHull(points, lw, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.beginPath();
    const len = points.length;
    for (let i = 0; i < len; i++) {
      const curr = points[i];
      const next = points[(i + 1) % len];
      const mx = (curr.x + next.x) / 2, my = (curr.y + next.y) / 2;
      if (i === 0) {
        const prev = points[len - 1];
        ctx.moveTo((prev.x + curr.x) / 2, (prev.y + curr.y) / 2);
      }
      ctx.quadraticCurveTo(curr.x, curr.y, mx, my);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // Outer glow
  drawSmoothHull(expandHull(pts, 15).map((p, i) => p), 8, `rgba(${avg.r},${avg.g},${avg.b},0.06)`);
  // Main membrane
  drawSmoothHull(pts, 1.5, `rgba(${avg.r},${avg.g},${avg.b},0.25)`);
  ctx.restore();
  return rawHull;
}

// ─── LIVING CONNECTIONS ───
function updateLivingConns(state, elapsed) {
  if (elapsed > state.nextConnEvent) {
    state.nextConnEvent = elapsed + 5000 + Math.random() * 5000;
    const idx = Math.floor(Math.random() * state.livingConns.length);
    state.livingConns[idx].visible = !state.livingConns[idx].visible;
  }
  state.livingConns.forEach(c => {
    const target = c.visible ? 1 : 0;
    c.fadeAlpha += (target - c.fadeAlpha) * 0.02;
  });
}

// ─── PULSE MANAGEMENT ───
function updatePulses(state, elapsed, nodes) {
  // Create new pulse if time
  if (elapsed > state.nextPulseTime) {
    const visConns = state.livingConns.filter(c => c.fadeAlpha > 0.3);
    if (visConns.length > 0) {
      const c = visConns[Math.floor(Math.random() * visConns.length)];
      state.pulses.push({
        from: c.from, to: c.to,
        progress: 0, speed: 0.003 + Math.random() * 0.002
      });
    }
    state.nextPulseTime = elapsed + 3000 + Math.random() * 2000;
  }
  // Update pulses
  state.pulses.forEach(p => { p.progress += p.speed; });
  // Brighten destination nodes
  state.pulses.forEach(p => {
    if (p.progress >= 0.95 && !p.arrived) {
      p.arrived = true;
      const dest = nodes.find(n => n.id === p.to);
      if (dest) dest.pulseGlow = 1.0;
    }
  });
  // Remove finished
  state.pulses = state.pulses.filter(p => p.progress < 1.2);
  // Decay node glow
  nodes.forEach(n => {
    if (n.pulseGlow) n.pulseGlow = Math.max(0, n.pulseGlow - 0.015);
  });
}

// ─── PARTICLE UPDATE ───
function updateParticles(state, nodes, mode) {
  if (!state.particles) return;
  state.particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vx += (Math.random() - 0.5) * 0.04;
    p.vy += (Math.random() - 0.5) * 0.04;
    p.vx *= 0.98;
    p.vy *= 0.98;
    // Keep in bounds
    const d = Math.hypot(p.x - CX, p.y - CY);
    if (d > 120) {
      const a = Math.atan2(p.y - CY, p.x - CX);
      p.x = CX + Math.cos(a) * 118;
      p.y = CY + Math.sin(a) * 118;
      p.vx *= -0.5; p.vy *= -0.5;
    }
  });
}

// ─── SHARED RENDER HELPERS ───
function findNode(nodes, id) { return nodes.find(n => n.id === id); }

function drawCrispConnection(ctx, a, b, al) {
  ctx.strokeStyle = rgba('#ffffff', al * 0.35);
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
}

function drawGentleBezier(ctx, a, b, al, time) {
  // Slight curve — control point offset perpendicular to midpoint
  const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
  const dx = b.x - a.x, dy = b.y - a.y;
  const len = Math.hypot(dx, dy) || 1;
  const nx = -dy / len, ny = dx / len;
  const offset = Math.sin(time / 5000 + a.x * 0.1) * 8;
  ctx.strokeStyle = rgba('#ffffff', al * 0.35);
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(a.x, a.y);
  ctx.quadraticCurveTo(mx + nx * offset, my + ny * offset, b.x, b.y);
  ctx.stroke();
}

function drawTendril(ctx, a, b, al, time, seedPhase) {
  const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
  const dx = b.x - a.x, dy = b.y - a.y;
  const len = Math.hypot(dx, dy) || 1;
  const nx = -dy / len, ny = dx / len;
  const phase = seedPhase || (a.x * 0.05 + a.y * 0.03);
  const offset = Math.sin(time / 4500 + phase) * (10 + len * 0.06);
  const mixColor = a.color || '#ffffff';
  ctx.strokeStyle = rgba(mixColor, al * 0.3);
  ctx.lineWidth = 2.2;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(a.x, a.y);
  ctx.quadraticCurveTo(mx + nx * offset, my + ny * offset, b.x, b.y);
  ctx.stroke();
  ctx.lineWidth = 1;
}

function drawNode(ctx, n, glow) {
  if (n.alpha < 0.01) return;
  const extra = (n.pulseGlow || 0) * 0.5;
  ctx.beginPath();
  ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
  ctx.fillStyle = rgba(n.color, n.alpha * (0.85 + extra));
  ctx.fill();
  if (glow) {
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.radius + 3, 0, Math.PI * 2);
    ctx.fillStyle = rgba(n.color, n.alpha * (0.12 + extra * 0.3));
    ctx.fill();
  }
}

function drawSoftOrb(ctx, n) {
  if (n.alpha < 0.01) return;
  const extra = (n.pulseGlow || 0) * 0.4;
  const r = n.radius * 2.5;
  const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
  grad.addColorStop(0, rgba(n.color, n.alpha * (0.7 + extra)));
  grad.addColorStop(0.4, rgba(n.color, n.alpha * (0.3 + extra * 0.5)));
  grad.addColorStop(1, rgba(n.color, 0));
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
  ctx.fill();
}

function drawPulse(ctx, pulse, nodes, bezierFn) {
  const a = findNode(nodes, pulse.from), b = findNode(nodes, pulse.to);
  if (!a || !b) return;
  const t = clamp(pulse.progress, 0, 1);
  // Interpolate along connection
  let px, py;
  if (bezierFn) {
    const pos = bezierFn(a, b, t);
    px = pos.x; py = pos.y;
  } else {
    px = lerp(a.x, b.x, t);
    py = lerp(a.y, b.y, t);
  }
  ctx.beginPath();
  ctx.arc(px, py, 2.5, 0, Math.PI * 2);
  ctx.fillStyle = rgba('#ffffff', 0.7 * (1 - Math.abs(t - 0.5) * 0.5));
  ctx.fill();
  // Small glow
  ctx.beginPath();
  ctx.arc(px, py, 6, 0, Math.PI * 2);
  ctx.fillStyle = rgba('#ffffff', 0.08);
  ctx.fill();
}

function drawGlowZones(ctx, nodes) {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  nodes.forEach(n => {
    if (n.alpha < 0.01) return;
    const r = n.type === 'primary' ? 55 : n.type === 'companion' ? 35 : n.type === 'satellite' ? 28 : 22;
    const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
    const baseA = n.type === 'primary' ? 0.06 : 0.035;
    grad.addColorStop(0, rgba(n.color, baseA * n.alpha));
    grad.addColorStop(0.5, rgba(n.color, baseA * 0.4 * n.alpha));
    grad.addColorStop(1, rgba(n.color, 0));
    ctx.fillStyle = grad;
    ctx.fillRect(n.x - r, n.y - r, r * 2, r * 2);
  });
  ctx.restore();
}

function drawParticles(ctx, state) {
  if (!state.particles) return;
  state.particles.forEach(p => {
    ctx.fillStyle = rgba(p.color, p.alpha);
    ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1);
  });
}

// ─── RENDERERS ───

// A — Pure Web + Gentle Curves
function renderA(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  let hull = null;
  if (mode === 'human') {
    hull = computeHull(nodes);
    if (hull) {
      const padded = expandHull(hull, 25);
      const inset = expandHull(hull, -10);
      containNodes(nodes, inset);
    }
  }

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawGentleBezier(ctx, a, b, al, time);
  });
  nodes.forEach(n => drawNode(ctx, n, false));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, false);
}

// B — Web + Undulating Tendrils
function renderB(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawTendril(ctx, a, b, al, time);
  });
  nodes.forEach(n => drawSoftOrb(ctx, n));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, true);
}

// C — Web + Neural Pulses
function renderC(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  updatePulses(state, elapsed, nodes);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawCrispConnection(ctx, a, b, al);
  });
  nodes.forEach(n => drawNode(ctx, n, true));
  // Pulses
  state.pulses.forEach(p => drawPulse(ctx, p, nodes));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, false);
}

// D — Web + Particle Dust
function renderD(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  updateParticles(state, nodes, mode);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  // Particles behind everything
  drawParticles(ctx, state);

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawCrispConnection(ctx, a, b, al);
  });
  nodes.forEach(n => drawNode(ctx, n, false));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, false);
}

// E — Tendrils + Pulses
function renderE(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  updatePulses(state, elapsed, nodes);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawTendril(ctx, a, b, al, time);
  });
  nodes.forEach(n => drawSoftOrb(ctx, n));
  // Pulses that follow bezier
  state.pulses.forEach(p => {
    const a = findNode(nodes, p.from), b = findNode(nodes, p.to);
    if (!a || !b) return;
    const t = clamp(p.progress, 0, 1);
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const dx = b.x - a.x, dy = b.y - a.y;
    const len = Math.hypot(dx, dy) || 1;
    const nx = -dy / len, ny = dx / len;
    const phase = a.x * 0.05 + a.y * 0.03;
    const offset = Math.sin(time / 4500 + phase) * (10 + len * 0.06);
    // Quadratic bezier interpolation
    const cx2 = mx + nx * offset, cy2 = my + ny * offset;
    const px = (1-t)*(1-t)*a.x + 2*(1-t)*t*cx2 + t*t*b.x;
    const py = (1-t)*(1-t)*a.y + 2*(1-t)*t*cy2 + t*t*b.y;
    ctx.beginPath();
    ctx.arc(px, py, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = rgba('#ffffff', 0.65 * (1 - Math.abs(t - 0.5) * 0.4));
    ctx.fill();
    ctx.beginPath();
    ctx.arc(px, py, 7, 0, Math.PI * 2);
    ctx.fillStyle = rgba('#ffffff', 0.06);
    ctx.fill();
  });
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, true);
}

// F — Web + Interior Glow Zones
function renderF(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  // Glow zones first
  drawGlowZones(ctx, nodes);
  // Crisp web on top
  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawCrispConnection(ctx, a, b, al);
  });
  nodes.forEach(n => drawNode(ctx, n, false));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, false);
}

// G — Full Mix: Tendrils + Dust + Pulses
function renderG(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  updatePulses(state, elapsed, nodes);
  updateParticles(state, nodes, mode);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  drawParticles(ctx, state);
  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawTendril(ctx, a, b, al, time);
  });
  nodes.forEach(n => drawSoftOrb(ctx, n));
  // Pulses along tendrils
  state.pulses.forEach(p => {
    const a = findNode(nodes, p.from), b = findNode(nodes, p.to);
    if (!a || !b) return;
    const t = clamp(p.progress, 0, 1);
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const dx = b.x - a.x, dy = b.y - a.y;
    const len = Math.hypot(dx, dy) || 1;
    const nx = -dy / len, ny = dx / len;
    const phase = a.x * 0.05 + a.y * 0.03;
    const offset = Math.sin(time / 4500 + phase) * (10 + len * 0.06);
    const cx2 = mx + nx * offset, cy2 = my + ny * offset;
    const px = (1-t)*(1-t)*a.x + 2*(1-t)*t*cx2 + t*t*b.x;
    const py = (1-t)*(1-t)*a.y + 2*(1-t)*t*cy2 + t*t*b.y;
    ctx.beginPath();
    ctx.arc(px, py, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = rgba('#ffffff', 0.6);
    ctx.fill();
  });
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, true);
}

// H — Web + Circuit Paths
function renderH(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    // 70% straight, then Manhattan turn at 70% mark near destination
    const t = 0.7;
    const midX = lerp(a.x, b.x, t);
    const midY = a.y; // stay on a's y-level
    ctx.strokeStyle = rgba('#22d3ee', al * 0.35);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(midX, midY); // horizontal/diagonal run
    ctx.lineTo(midX, b.y);  // vertical turn
    ctx.lineTo(b.x, b.y);   // final horizontal
    ctx.stroke();
    // Junction dot at each bend
    ctx.fillStyle = rgba('#22d3ee', al * 0.5);
    ctx.beginPath(); ctx.arc(midX, midY, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(midX, b.y, 1.5, 0, Math.PI * 2); ctx.fill();
  });
  // Rounded-rect nodes
  nodes.forEach(n => {
    if (n.alpha < 0.01) return;
    const s = n.radius * 1.3;
    const r = 2;
    ctx.fillStyle = rgba(n.color, n.alpha * 0.85);
    ctx.beginPath();
    ctx.moveTo(n.x - s + r, n.y - s);
    ctx.lineTo(n.x + s - r, n.y - s);
    ctx.arcTo(n.x + s, n.y - s, n.x + s, n.y - s + r, r);
    ctx.lineTo(n.x + s, n.y + s - r);
    ctx.arcTo(n.x + s, n.y + s, n.x + s - r, n.y + s, r);
    ctx.lineTo(n.x - s + r, n.y + s);
    ctx.arcTo(n.x - s, n.y + s, n.x - s, n.y + s - r, r);
    ctx.lineTo(n.x - s, n.y - s + r);
    ctx.arcTo(n.x - s, n.y - s, n.x - s + r, n.y - s, r);
    ctx.closePath();
    ctx.fill();
    // Inner pip
    ctx.fillStyle = rgba('#ffffff', n.alpha * 0.4);
    ctx.fillRect(n.x - 0.8, n.y - 0.8, 1.6, 1.6);
  });
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, false);
}

// I — Tendrils + Glow Zones
function renderI(ctx, state, elapsed, time, mode) {
  const { nodes, livingConns } = state;
  updateLivingConns(state, elapsed);
  nodes.forEach(n => { applyDrift(n, time); n.alpha = getNodeAlpha(n, elapsed); });

  if (mode === 'human') {
    const hull = computeHull(nodes);
    if (hull) containNodes(nodes, expandHull(hull, -10));
  }

  // Glow zones first
  drawGlowZones(ctx, nodes);
  // Tendrils on top
  livingConns.forEach(c => {
    const a = findNode(nodes, c.from), b = findNode(nodes, c.to);
    if (!a || !b) return;
    const al = Math.min(a.alpha, b.alpha) * c.fadeAlpha;
    if (al < 0.01) return;
    drawTendril(ctx, a, b, al, time);
  });
  // Soft orbs that merge with glow zones
  nodes.forEach(n => drawSoftOrb(ctx, n));
  if (mode === 'human') drawMembrane(ctx, nodes, state, time, true);
}

const RENDERERS = { A: renderA, B: renderB, C: renderC, D: renderD, E: renderE, F: renderF, G: renderG, H: renderH, I: renderI };

// ─── SETUP ───
const grid = document.getElementById('grid');

CARD_DEFS.forEach(def => {
  const card = document.createElement('div');
  card.className = 'card';
  const canvas = document.createElement('canvas');
  canvas.width = CW * DPR;
  canvas.height = CH * DPR;
  canvas.style.width = CW + 'px';
  canvas.style.height = CH + 'px';
  card.appendChild(canvas);
  const label = document.createElement('div');
  label.className = 'card-label';
  label.innerHTML = `<span>${def.id}</span> — ${def.name}<span class="sub">${def.sub}</span>`;
  card.appendChild(label);
  grid.appendChild(card);
  canvases[def.id] = canvas;
});

function initAll() {
  CARD_DEFS.forEach(def => initCard(def.id));
}

function setTier(t) {
  if (t === 'random') {
    const tiers = ['seed', 'young', 'full'];
    currentTier = tiers[Math.floor(Math.random() * 3)];
  } else {
    currentTier = t;
  }
  document.querySelectorAll('.controls button').forEach(b => {
    if (b.id.startsWith('btn-seed') || b.id.startsWith('btn-young') || b.id.startsWith('btn-full') || b.id.startsWith('btn-random')) {
      b.classList.toggle('active', b.id === `btn-${t}`);
    }
  });
  initAll();
}

function setMode(m) {
  currentMode = m;
  document.getElementById('btn-human').classList.toggle('active', m === 'human');
  document.getElementById('btn-ai').classList.toggle('active', m === 'ai');
}

// ─── ANIMATION LOOP ───
function animate(time) {
  CARD_DEFS.forEach(def => {
    const state = cardStates[def.id];
    if (!state) return;
    const canvas = canvases[def.id];
    const ctx = canvas.getContext('2d');
    // Reset canvas
    canvas.width = CW * DPR;
    canvas.height = CH * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, CW, CH);

    const elapsed = time - state.startTime;
    RENDERERS[def.id](ctx, state, elapsed, time, currentMode);
  });
  requestAnimationFrame(animate);
}

initAll();
requestAnimationFrame(animate);
</script>
</body>
</html>