<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aura Viz — Warm Canvas v2</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #030712; color: #e5e7eb;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh; padding: 20px;
  }
  .page { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 16px; }
  .header { text-align: center; }
  .header h1 { font-size: 15px; font-weight: 700; color: #fff; }
  .header p { font-size: 11px; color: #6b7280; margin-top: 4px; }
  .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
  @media (max-width: 900px) { .grid { grid-template-columns: repeat(2, 1fr); } }
  .cell {
    display: flex; flex-direction: column; align-items: center; gap: 6px;
    padding: 12px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.015);
    cursor: pointer; transition: all 0.3s;
  }
  .cell:hover { border-color: rgba(139,92,246,0.3); }
  .cell.picked { border-color: rgba(16,185,129,0.5); background: rgba(16,185,129,0.04); }
  .cell-label { font-size: 11px; font-weight: 600; color: #fff; }
  .cell-desc { font-size: 9px; color: #6b7280; text-align: center; line-height: 1.4; }
  .cell-tag { font-size: 8px; padding: 2px 8px; border-radius: 10px; text-transform: uppercase; letter-spacing: 0.08em; font-weight: 600; }
  .tag-ref { color: #10b981; border: 1px solid rgba(16,185,129,0.3); }
  .tag-var { color: #8b5cf6; border: 1px solid rgba(139,92,246,0.3); }
  .controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
  .ctrl-btn {
    padding: 7px 14px; border: 1px solid #374151; border-radius: 8px;
    background: transparent; color: #9ca3af; font-size: 11px; font-weight: 500;
    cursor: pointer; transition: all 0.2s; font-family: inherit;
  }
  .ctrl-btn:hover { border-color: #6b7280; color: #fff; }
  .ctrl-btn.active { border-color: #8b5cf6; color: #fff; background: rgba(139,92,246,0.12); }
  .ctrl-btn.preset { border-color: #f59e0b; color: #f59e0b; }
  .ctrl-btn.preset.active { background: rgba(245,158,11,0.15); color: #fbbf24; }
  .divider { width: 100%; max-width: 500px; height: 1px; background: #1f2937; margin: 0 auto; }
  .section-label { font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em; color: #6b7280; font-weight: 600; text-align: center; }
  .pick-bar {
    display: flex; gap: 8px; justify-content: center; padding: 8px;
    background: rgba(16,185,129,0.06); border-radius: 8px; border: 1px solid rgba(16,185,129,0.15);
  }
  .pick-bar span { font-size: 11px; color: #10b981; }
</style>
</head>
<body>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">

// ═══════════════════════════════════════════════════════
// WARM AURA VIZ v2 — Per-primary glow, tunable everything
// ═══════════════════════════════════════════════════════

const WarmAuraViz = React.memo(function WarmAuraViz({
  onboardingAnswers = {},
  assessCompleted = {},
  entityType = 'human',
  darkMode = true,
  size = 240,
  tuning = {},
}) {
  const canvasRef = React.useRef(null);
  const stateRef = React.useRef(null);
  const animRef = React.useRef(null);
  const propsRef = React.useRef({ onboardingAnswers, assessCompleted, entityType, darkMode, size, tuning });
  propsRef.current = { onboardingAnswers, assessCompleted, entityType, darkMode, size, tuning };

  const C = {
    violet:'#8b5cf6', blue:'#3b82f6', teal:'#14b8a6', rose:'#f43f5e',
    pink:'#d946ef', emerald:'#10b981', amber:'#f59e0b', indigo:'#6366f1', cyan:'#06b6d4',
  };

  function hexRgb(hex) { const n=parseInt(hex.slice(1),16); return [(n>>16)&255,(n>>8)&255,n&255]; }
  function lerp(a,b,t) { return a+(b-a)*t; }
  function lerpRgb(a,b,t) { return [lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)]; }
  function rgbStr(c,a) { return `rgba(${c[0]|0},${c[1]|0},${c[2]|0},${a.toFixed(3)})`; }
  function seededRng(seed) { let s=seed; return()=>{s=(s*16807+0)%2147483647;return s/2147483647;}; }

  const NEURON_MAP = [
    { colorQ:'onboard-1', posQ:'onboard-2', colors:[C.violet,C.blue] },
    { colorQ:'onboard-4', posQ:'onboard-8', colors:[C.indigo,C.rose] },
    { colorQ:'onboard-5', posQ:'onboard-3', colors:[C.pink,C.teal] },
    { colorQ:'onboard-6', posQ:'onboard-9', colors:[C.emerald,C.amber] },
    { colorQ:'onboard-7', posQ:'onboard-10', colors:[C.cyan,C.violet] },
  ];
  const SENSITIVE=[false,false,false,true,true];
  const HUMAN_CONNS=[[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,3],[1,4]];
  const AI_CONNS=[[0,1],[0,2],[1,2],[2,3],[2,4],[3,4],[0,4],[1,3],[0,3],[1,4]];
  const ASSESS_MAP = [
    {ids:['starter-personality'],color:C.violet,tier:1,nodes:3,affinities:[0,2]},
    {ids:['starter-motivation'],color:C.amber,tier:1,nodes:3,affinities:[1,3]},
    {ids:['starter-thinking'],color:C.blue,tier:1,nodes:3,affinities:[0,4]},
    {ids:['starter-connection'],color:C.pink,tier:1,nodes:3,affinities:[2,3]},
    {ids:['starter-strategy'],color:C.emerald,tier:1,nodes:3,affinities:[1,4]},
    {ids:['bigfive-E','bigfive-A','bigfive-C','bigfive-N','bigfive-O'],color:C.violet,tier:2,nodes:5,affinities:[0,2,4]},
    {ids:['integrity'],color:C.emerald,tier:2,nodes:3,affinities:[3,1]},
    {ids:['shadow-M','shadow-N','shadow-P'],color:C.indigo,tier:2,nodes:4,affinities:[3,4]},
    {ids:['adhd','cognitive','chronotype','reasoning'],color:C.cyan,tier:2,nodes:4,affinities:[4,0]},
    {ids:['attachment'],color:C.rose,tier:2,nodes:3,affinities:[2,3]},
    {ids:['risk'],color:C.amber,tier:2,nodes:3,affinities:[1,4]},
  ];

  function deriveAnswers(answers) {
    const colorAns=new Array(5).fill(null),posAns=new Array(5).fill(null);
    for(let i=0;i<5;i++){const nm=NEURON_MAP[i];if(nm.colorQ in answers)colorAns[i]=answers[nm.colorQ];if(nm.posQ in answers)posAns[i]=answers[nm.posQ];}
    return{colorAns,posAns};
  }
  function deriveAssessState(completed){const s={};ASSESS_MAP.forEach((a,i)=>{s[i]=a.ids.some(id=>id in completed);});return s;}

  function makeNode(o) {
    return {
      x:o.x||300,y:o.y||300,tx:o.x||300,ty:o.y||300,
      color:o.color?hexRgb(o.color):[70,75,90],tcolor:o.color?hexRgb(o.color):[70,75,90],
      r:o.r||2,tr:o.r||2,halo:o.halo||8,thalo:o.halo||8,alpha:0,talpha:0,
      phase:Math.random()*Math.PI*2,orbitAngle:Math.random()*Math.PI*2,
      orbitSpeed:(Math.random()-0.5)*0.006,
      driftSpeed:0.35+Math.random()*0.5,driftAmp:2.5+Math.random()*3.5,
      phaseX:Math.random()*6,phaseY:Math.random()*6,flash:0,
      type:o.type||'primary',parent:o.parent??-1,sensitive:o.sensitive||false,
      assessIdx:o.assessIdx??null,affinities:o.affinities||null,tier:o.tier||0,
    };
  }

  function answerHashFn(ca,pa){let h=0;for(let i=0;i<5;i++){h=h*31+(ca[i]!==null?ca[i]+1:0);h=h*37+(pa[i]!==null?pa[i]+1:0);}return h;}

  function primarySeedPositions(colorAns,posAns,isAI,t) {
    const CX=300,CY=300,hash=answerHashFn(colorAns,posAns),rng=seededRng(hash+7919);
    const answeredCount=colorAns.filter(a=>a!==null).length+posAns.filter(a=>a!==null).length;
    const spread=t.tightCluster?(0.5+answeredCount*0.05):1.0;
    const baseAngles=[0,1,2,3,4].map(i=>{
      let a=(i/5)*Math.PI*2;
      if(posAns[i]!==null) a+=(posAns[i]===0?-0.7:0.7);
      if(colorAns[i]!==null) a+=(colorAns[i]===0?-0.35:0.35);
      a+=(hash%628)/100; return a;
    });
    return [0,1,2,3,4].map(i=>{
      const ans=colorAns[i]!==null||posAns[i]!==null;
      const r=(ans?110+rng()*70:65+rng()*45)*spread;
      return{x:CX+Math.cos(baseAngles[i])*r,y:CY+Math.sin(baseAngles[i])*r};
    });
  }

  function buildAllNodes(assessState,colorAns,posAns,isAI,t) {
    const nodes=[],CX=300,CY=300;
    const seeds=primarySeedPositions(colorAns,posAns,isAI,t);
    for(let i=0;i<5;i++) nodes.push(makeNode({x:seeds[i].x,y:seeds[i].y,r:5,halo:22,type:'primary',sensitive:SENSITIVE[i]}));
    if(!t.primariesOnly){
      for(let i=0;i<5;i++) for(let c=0;c<2;c++){
        const a=Math.random()*Math.PI*2,d=8+Math.random()*12;
        nodes.push(makeNode({x:nodes[i].x+Math.cos(a)*d,y:nodes[i].y+Math.sin(a)*d,type:'companion',parent:i,r:2.5,halo:10}));
      }
      for(let s=0;s<5;s++) nodes.push(makeNode({x:(nodes[s].x+CX)/2+(Math.random()-0.5)*30,y:(nodes[s].y+CY)/2+(Math.random()-0.5)*30,type:'satellite',parent:s,r:2,halo:7}));
      ASSESS_MAP.forEach((assess,ai)=>{
        if(!assessState[ai])return;
        const rng=seededRng(ai*137+42),affs=assess.affinities;
        for(let ni=0;ni<assess.nodes;ni++){
          let mx=0,my=0;for(const pi of affs){mx+=nodes[pi].x;my+=nodes[pi].y;}mx/=affs.length;my/=affs.length;
          nodes.push(makeNode({x:mx+(rng()-0.5)*50,y:my+(rng()-0.5)*50,r:2+rng()*2,halo:8+rng()*10,type:'assess',color:assess.color,assessIdx:ai,tier:assess.tier,parent:affs[0],affinities:affs}));
        }
      });
    }
    return nodes;
  }

  function buildEdges(nodes,isAI,colorAns,posAns,t) {
    const edges=[],N=nodes.length,s=new Set();
    function add(a,b,str,rest){const k=Math.min(a,b)*10000+Math.max(a,b);if(s.has(k))return;s.add(k);edges.push({a,b,strength:str,restLen:rest});}
    const rs=t.tightCluster?0.7:1.0;
    const pc=isAI?AI_CONNS:HUMAN_CONNS;
    for(const[a,b]of pc){const aa=colorAns[a],bb=colorAns[b],both=aa!==null&&bb!==null,same=both&&aa===bb;add(a,b,both?(same?1:0.5):0.3,(both?(same?60:110):100)*rs);}
    if(!t.primariesOnly){
      for(let ci=5;ci<15;ci++) add(nodes[ci].parent,ci,1.5,25*rs);
      for(let i=0;i<5;i++) add(5+i*2,5+i*2+1,0.8,12*rs);
      for(let i=0;i<5;i++) add(5+i*2+1,5+((i+1)%5)*2,0.2,60*rs);
      for(let si=15;si<20;si++) add(nodes[si].parent,si,0.5,70*rs);
      for(let si=0;si<5;si++) add(15+si,15+(si+1)%5,0.15,70*rs);
      for(let ai=20;ai<N;ai++){
        const an=nodes[ai];if(an.affinities)for(const pi of an.affinities)add(pi,ai,0.6,60*rs);
      }
    }
    return edges;
  }

  function simulateForces(nodes,edges,isAI,dt,t) {
    if(t.noForce) return; // Skip force sim entirely
    const CX=300,CY=300,N=nodes.length;if(N===0)return;
    for(const n of nodes){n.fx=0;n.fy=0;}
    for(const e of edges){
      const na=nodes[e.a],nb=nodes[e.b];if(na.alpha<0.02&&nb.alpha<0.02)continue;
      const dx=nb.x-na.x,dy=nb.y-na.y,dist=Math.sqrt(dx*dx+dy*dy)||0.1;
      const f=e.strength*(dist-e.restLen)/dist;na.fx+=dx*f;na.fy+=dy*f;nb.fx-=dx*f;nb.fy-=dy*f;
    }
    const rep=(isAI?3500:5500)*(t.repulsionScale??1);
    for(let i=0;i<N;i++){if(nodes[i].alpha<0.02)continue;for(let j=i+1;j<N;j++){if(nodes[j].alpha<0.02)continue;
      const dx=nodes[j].x-nodes[i].x,dy=nodes[j].y-nodes[i].y,d=Math.sqrt(Math.max(dx*dx+dy*dy,100));
      const f=-rep/(d*d),fx=(dx/d)*f,fy=(dy/d)*f;nodes[i].fx+=fx;nodes[i].fy+=fy;nodes[j].fx-=fx;nodes[j].fy-=fy;
    }}
    const grav=t.gravity??0.04;
    for(const n of nodes){if(n.alpha<0.02)continue;n.fx+=(CX-n.x)*grav;n.fy+=(CY-n.y)*grav;}
    for(const n of nodes){if(n.alpha<0.02)continue;
      const mass=n.type==='primary'?3:n.type==='companion'?0.8:1.2;
      n.vx=(n.vx+n.fx/mass*dt)*0.85;n.vy=(n.vy+n.fy/mass*dt)*0.85;
      const sp=Math.sqrt(n.vx*n.vx+n.vy*n.vy);if(sp>8){n.vx*=8/sp;n.vy*=8/sp;}
      n.tx=n.x+n.vx;n.ty=n.y+n.vy;
      if(n.tx<40)n.vx+=2;if(n.tx>560)n.vx-=2;if(n.ty<40)n.vy+=2;if(n.ty>560)n.vy-=2;
    }
  }

  function computeAppearance(nodes,isAI,colorAns,posAns,assessState,t) {
    const ac=colorAns.filter(a=>a!==null).length+posAns.filter(a=>a!==null).length;
    for(let i=0;i<5;i++){
      const node=nodes[i];
      if(colorAns[i]!==null){
        node.tcolor=hexRgb(NEURON_MAP[i].colors[colorAns[i]]);
        node.tr=t.answeredR??12;node.thalo=t.answeredHalo??45;node.talpha=1;
      } else if(posAns[i]!==null){
        const c0=hexRgb(NEURON_MAP[i].colors[0]),c1=hexRgb(NEURON_MAP[i].colors[1]);
        node.tcolor=[Math.round((c0[0]+c1[0])*0.25+50*0.5),Math.round((c0[1]+c1[1])*0.25+55*0.5),Math.round((c0[2]+c1[2])*0.25+70*0.5)];
        node.talpha=0.6;node.tr=8;node.thalo=32;
      } else {
        const c0=hexRgb(NEURON_MAP[i].colors[0]),c1=hexRgb(NEURON_MAP[i].colors[1]);
        node.tcolor=lerpRgb(c0,c1,0.5); // Use actual blended color, not gray
        node.tr=t.ghostR??6;node.thalo=24;node.talpha=t.ghostAlpha??0.45;
      }
    }
    if(!t.primariesOnly){
      for(let ci=0;ci<10;ci++){
        const node=nodes[5+ci],parent=nodes[node.parent];
        const ans=colorAns[node.parent]!==null||posAns[node.parent]!==null;
        if(t.earnedCompanions&&!ans){node.talpha=0;}
        else if(ans){node.tcolor=parent.tcolor;node.tr=4+(ci%2)*2;node.thalo=16+(ci%2)*6;node.talpha=parent.talpha*(t.companionAlpha??0.6);}
        else{node.tcolor=parent.tcolor;node.tr=2.5;node.thalo=10;node.talpha=t.companionGhostAlpha??0.2;}
      }
      const satT=t.satThreshold??6;
      for(let si=0;si<5;si++){
        const node=nodes[15+si],parent=nodes[node.parent];
        if(ac>=satT&&parent.talpha>0.3){node.tcolor=parent.tcolor;node.tr=4;node.thalo=14;node.talpha=0.5*Math.min(1,(ac-satT+1)/4);}
        else{node.talpha=0;}
      }
      for(let ai=20;ai<nodes.length;ai++){
        const node=nodes[ai];
        if(assessState[node.assessIdx]){
          node.talpha=0.85;node.tr=5;node.thalo=18;
          if(node.affinities&&node.affinities.length>=2){
            let ar=0,ag=0,ab=0;for(const pi of node.affinities){ar+=nodes[pi].color[0];ag+=nodes[pi].color[1];ab+=nodes[pi].color[2];}
            const n=node.affinities.length;node.tcolor=lerpRgb(hexRgb(ASSESS_MAP[node.assessIdx].color),[ar/n,ag/n,ab/n],0.6);
          }
        }else{node.talpha=0;}
      }
    }
  }

  function diamond(ctx,cx,cy,s){ctx.beginPath();ctx.moveTo(cx,cy-s);ctx.lineTo(cx+s,cy);ctx.lineTo(cx,cy+s);ctx.lineTo(cx-s,cy);ctx.closePath();}
  function triangle(ctx,cx,cy,s){const h=s*1.15;ctx.beginPath();ctx.moveTo(cx,cy-h);ctx.lineTo(cx+s,cy+h*0.5);ctx.lineTo(cx-s,cy+h*0.5);ctx.closePath();}

  function animPos(n,time,isAI,t) {
    const dm=t.driftMult??1,sp=n.driftSpeed,amp=n.driftAmp*(isAI?0.2:1.3)*dm;
    const sh=t.secondHarmonic??0.3;
    const dx=Math.sin(time*sp+n.phaseX)*amp+Math.sin(time*sp*0.4+n.phaseX*2.1)*amp*sh;
    const dy=Math.cos(time*sp*0.75+n.phaseY)*amp+Math.cos(time*sp*0.35+n.phaseY*1.7)*amp*sh*0.83;
    const w=isAI?0.6:(t.wobble??4);
    return{x:n.x+dx+Math.cos(n.orbitAngle*0.7+time*0.15)*w,y:n.y+dy+Math.sin(n.orbitAngle*0.9+time*0.12)*w};
  }

  // ═══════════════════════════════════════════════════════
  // RENDER — with per-primary glow option
  // ═══════════════════════════════════════════════════════
  function render(ctx,nodes,conns,stars,isAI,time,scale,t) {
    const W=600,H=600,CX=300,CY=300;
    const breathAmp=t.breathAmp??0.04,breathSpd=t.breathSpd??0.3;
    const breath=1+breathAmp*Math.sin(time*breathSpd);

    ctx.save();ctx.scale(scale,scale);
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle=isAI?'#020810':'#060712';ctx.fillRect(0,0,W,H);

    // Stars
    const starCount=t.stars??100;
    for(let i=0;i<Math.min(starCount,stars.length);i++){
      const s=stars[i];
      const tw=s.bright*(0.5+0.5*Math.sin(time*s.speed+s.phase));
      ctx.beginPath();ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fillStyle=rgbStr([180,200,255],tw);ctx.fill();
    }

    // AI grid
    if(isAI&&!t.noGrid){
      ctx.save();ctx.translate(CX,CY);ctx.rotate(time*0.015);ctx.translate(-CX,-CY);
      ctx.strokeStyle='#6b7b93';ctx.lineWidth=0.6;
      for(let ring=1;ring<=7;ring++){ctx.globalAlpha=Math.max(0.005,0.10-ring*0.012);ctx.beginPath();
        for(let i=0;i<=6;i++){const a=(i/6)*Math.PI*2-Math.PI/6,r=ring*40;i===0?ctx.moveTo(CX+Math.cos(a)*r,CY+Math.sin(a)*r):ctx.lineTo(CX+Math.cos(a)*r,CY+Math.sin(a)*r);}
        ctx.stroke();}
      ctx.restore();
    }

    // ═══ GLOW SYSTEM ═══
    const glowMode = t.glowMode ?? 'aggregate';

    if (glowMode === 'perPrimary') {
      // Per-primary radial glow — each of 5 primaries radiates its own color
      // This is what gives the SVG its distinct multi-color feel
      const glowR = t.glowRadius ?? 120;
      const glowAlpha = t.glowAlpha ?? 0.5;
      for (let i = 0; i < 5; i++) {
        const n = nodes[i];
        if (n.alpha < 0.03) continue;
        const p = animPos(n, time, isAI, t);
        const r = glowR * (0.6 + n.alpha * 0.4) * breath;
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
        g.addColorStop(0, rgbStr(n.color, n.alpha * glowAlpha));
        g.addColorStop(0.4, rgbStr(n.color, n.alpha * glowAlpha * 0.5));
        g.addColorStop(0.7, rgbStr(n.color, n.alpha * glowAlpha * 0.15));
        g.addColorStop(1, rgbStr(n.color, 0));
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI * 2); ctx.fill();
      }
    } else if (glowMode === 'perNode') {
      // Per-node glow — every visible node radiates, weighted by importance
      const baseR = t.glowRadius ?? 80;
      const glowAlpha = t.glowAlpha ?? 0.35;
      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i]; if (n.alpha < 0.05) continue;
        const p = animPos(n, time, isAI, t);
        const weight = n.type === 'primary' ? 1.0 : n.type === 'companion' ? 0.3 : n.type === 'assess' ? 0.5 : 0.2;
        const r = baseR * weight * (0.6 + n.alpha * 0.4) * breath;
        if (r < 5) continue;
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
        g.addColorStop(0, rgbStr(n.color, n.alpha * glowAlpha * weight));
        g.addColorStop(0.5, rgbStr(n.color, n.alpha * glowAlpha * weight * 0.3));
        g.addColorStop(1, rgbStr(n.color, 0));
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI * 2); ctx.fill();
      }
    } else {
      // 'aggregate' — v12 production style: group by color, one blur blob per zone
      const colorKey=(c)=>c[0]+','+c[1]+','+c[2];
      const zones={};
      for(let i=0;i<nodes.length;i++){
        const n=nodes[i];if(n.alpha<0.05)continue;
        const p=animPos(n,time,isAI,t),k=colorKey(n.color);
        if(!zones[k])zones[k]={color:n.color,sx:0,sy:0,weight:0,count:0};
        const w=n.alpha*(n.type==='primary'?2.5:n.type==='assess'?1.5:0.8);
        zones[k].sx+=p.x*w;zones[k].sy+=p.y*w;zones[k].weight+=w;zones[k].count++;
      }
      ctx.save();ctx.filter=`blur(${t.glowBlur??50}px)`;
      for(const zone of Object.values(zones)){
        const cx=zone.sx/zone.weight,cy=zone.sy/zone.weight;
        ctx.fillStyle=rgbStr(zone.color,Math.min(0.65,zone.weight*0.12)*breath*(t.glowOpacity??1));
        ctx.beginPath();ctx.arc(cx,cy,70+zone.count*16,0,Math.PI*2);ctx.fill();
      }
      ctx.restore();
    }

    // Connections
    if (!t.noConnections) {
      const cAlpha=t.connAlpha??0.3,cCurve=t.connCurve??14;
      for(const[a,b]of conns){
        const na=nodes[a],nb=nodes[b];if(na.alpha<0.03||nb.alpha<0.03)continue;
        const pa=animPos(na,time,isAI,t),pb=animPos(nb,time,isAI,t);
        const dx=pa.x-pb.x,dy=pa.y-pb.y,dist=Math.sqrt(dx*dx+dy*dy);
        const lineA=Math.max(0,1-dist/400)*Math.min(na.alpha,nb.alpha)*cAlpha*(a>=20||b>=20?0.6:1);
        if(lineA<0.005)continue;
        ctx.beginPath();
        if(isAI){ctx.moveTo(pa.x,pa.y);ctx.lineTo(pb.x,pb.y);}
        else{ctx.moveTo(pa.x,pa.y);ctx.quadraticCurveTo((pa.x+pb.x)/2+Math.sin(time*0.15+a+b)*cCurve,(pa.y+pb.y)/2+Math.cos(time*0.1+a*0.7)*cCurve,pb.x,pb.y);}
        ctx.strokeStyle=rgbStr([255,255,255],lineA);ctx.lineWidth=t.connWidth??1;ctx.lineCap='round';ctx.stroke();
      }
    }

    // Nodes
    const order=[];for(let i=0;i<nodes.length;i++)order.push(i);
    order.sort((a,b)=>nodes[a].alpha-nodes[b].alpha);
    const haloScale=t.haloScale??3;
    for(const idx of order){
      const n=nodes[idx];if(n.alpha<0.02)continue;
      const p=animPos(n,time,isAI,t),c=n.color,ba=n.alpha;
      const cR=(n.r+n.flash*3)*breath;
      // Outer halo
      if(cR>1){
        const outerR=cR*haloScale;
        const g1=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,outerR);
        g1.addColorStop(0,rgbStr(c,ba*(t.haloInner??0.22)));g1.addColorStop(0.5,rgbStr(c,ba*(t.haloMid??0.08)));g1.addColorStop(1,rgbStr(c,0));
        if(isAI&&n.type==='primary'){ctx.save();if(n.sensitive)triangle(ctx,p.x,p.y,outerR*1.3);else diamond(ctx,p.x,p.y,outerR*1.3);ctx.clip();ctx.fillStyle=g1;ctx.fillRect(p.x-outerR,p.y-outerR,outerR*2,outerR*2);ctx.restore();}
        else{ctx.beginPath();ctx.arc(p.x,p.y,outerR,0,Math.PI*2);ctx.fillStyle=g1;ctx.fill();}
      }
      // Mid glow
      if(cR>0.5){ctx.beginPath();if(isAI&&n.type==='primary'){if(n.sensitive)triangle(ctx,p.x,p.y,cR*1.8);else diamond(ctx,p.x,p.y,cR*1.8);}else ctx.arc(p.x,p.y,cR*1.8,0,Math.PI*2);ctx.fillStyle=rgbStr(c,ba*0.35);ctx.fill();}
      // Core
      if(cR>0.3){ctx.beginPath();if(isAI&&n.type==='primary'){if(n.sensitive)triangle(ctx,p.x,p.y,cR);else diamond(ctx,p.x,p.y,cR);}else ctx.arc(p.x,p.y,cR,0,Math.PI*2);ctx.fillStyle=rgbStr(c,ba*0.95);ctx.fill();}
      // Pip
      if(cR>0.8){ctx.beginPath();if(isAI&&n.type==='primary'){if(n.sensitive)triangle(ctx,p.x,p.y,cR*0.4);else diamond(ctx,p.x,p.y,cR*0.4);}else ctx.arc(p.x,p.y,cR*0.4,0,Math.PI*2);ctx.fillStyle=rgbStr([255,255,255],ba*0.65);ctx.fill();}
      // Flash
      if(n.flash>0.05){const fR=cR*(3+(1-n.flash)*8);if(isAI&&n.type==='primary'&&n.sensitive)triangle(ctx,p.x,p.y,fR);else if(isAI&&n.type==='primary')diamond(ctx,p.x,p.y,fR);else{ctx.beginPath();ctx.arc(p.x,p.y,fR,0,Math.PI*2);}ctx.strokeStyle=rgbStr(c,n.flash*0.4);ctx.lineWidth=2*n.flash;ctx.stroke();}
    }
    ctx.restore();
  }

  // Init + prop changes + animation loop (same structure as v1)
  React.useEffect(()=>{
    const{onboardingAnswers,assessCompleted,entityType,tuning:t}=propsRef.current;
    const{colorAns,posAns}=deriveAnswers(onboardingAnswers);
    const assessState=deriveAssessState(assessCompleted);
    const nodes=buildAllNodes(assessState,colorAns,posAns,entityType==='ai',t);
    for(const n of nodes){n.vx=0;n.vy=0;}
    const stars=[];for(let i=0;i<120;i++)stars.push({x:Math.random()*600,y:Math.random()*600,r:0.2+Math.random()*0.9,bright:Math.random()*0.35+0.05,phase:Math.random()*Math.PI*2,speed:0.5+Math.random()*2.5});
    stateRef.current={nodes,stars,conns:[],lastTime:performance.now(),prevAK:'',prevAsK:'',prevET:''};
  },[]);

  React.useEffect(()=>{
    if(!stateRef.current)return;const{nodes}=stateRef.current;
    const{onboardingAnswers,assessCompleted,entityType,tuning:t}=propsRef.current;
    const ak=JSON.stringify(onboardingAnswers),ask=JSON.stringify(Object.keys(assessCompleted).sort());
    const ac=ak!==stateRef.current.prevAK,asc=ask!==stateRef.current.prevAsK,ec=entityType!==stateRef.current.prevET;
    stateRef.current.prevAK=ak;stateRef.current.prevAsK=ask;stateRef.current.prevET=entityType;
    if(ec)for(const n of nodes)if(n.alpha>0.05)n.flash=0.6;
    if(asc){
      const{colorAns,posAns}=deriveAnswers(onboardingAnswers);
      const assessState=deriveAssessState(assessCompleted);
      if(!t.primariesOnly){
        nodes.length=20;
        ASSESS_MAP.forEach((assess,ai)=>{if(!assessState[ai])return;const rng=seededRng(ai*137+42),affs=assess.affinities;
          for(let ni=0;ni<assess.nodes;ni++){let mx=0,my=0;for(const pi of affs){mx+=nodes[pi].x;my+=nodes[pi].y;}mx/=affs.length;my/=affs.length;
            const nd=makeNode({x:mx+(rng()-0.5)*50,y:my+(rng()-0.5)*50,r:2+rng()*2,halo:8+rng()*10,type:'assess',color:assess.color,assessIdx:ai,tier:assess.tier,parent:affs[0],affinities:affs});nd.vx=0;nd.vy=0;nodes.push(nd);}
        });for(let i=20;i<nodes.length;i++)nodes[i].flash=0.5;
      }
    }
    if(ac&&!ec){
      const{colorAns,posAns}=deriveAnswers(onboardingAnswers);
      const seeds=primarySeedPositions(colorAns,posAns,entityType==='ai',t);
      for(let i=0;i<5;i++){nodes[i].flash=1;nodes[i].vx=(nodes[i].vx||0)+(seeds[i].x-nodes[i].x)*0.15;nodes[i].vy=(nodes[i].vy||0)+(seeds[i].y-nodes[i].y)*0.15;
        if(nodes[5+i*2])nodes[5+i*2].flash=0.6;if(nodes[5+i*2+1])nodes[5+i*2+1].flash=0.5;}
    }
  },[onboardingAnswers,assessCompleted,entityType]);

  React.useEffect(()=>{
    const canvas=canvasRef.current;if(!canvas)return;const ctx=canvas.getContext('2d');
    function frame(now){
      if(!stateRef.current){animRef.current=requestAnimationFrame(frame);return;}
      const{nodes,stars}=stateRef.current;
      const{onboardingAnswers,assessCompleted,entityType,size,tuning:t}=propsRef.current;
      const scale=size/600,isAI=entityType==='ai';
      const{colorAns,posAns}=deriveAnswers(onboardingAnswers);
      const assessState=deriveAssessState(assessCompleted);
      const dt=Math.min((now-stateRef.current.lastTime)/1000,0.05);stateRef.current.lastTime=now;const time=now/1000;
      computeAppearance(nodes,isAI,colorAns,posAns,assessState,t);
      const edges=buildEdges(nodes,isAI,colorAns,posAns,t);
      simulateForces(nodes,edges,isAI,dt,t);
      const conns=[];for(const e of edges)if(nodes[e.a].alpha>0.03&&nodes[e.b].alpha>0.03)conns.push([e.a,e.b]);
      const spd=6*dt;
      for(const n of nodes){n.x=lerp(n.x,n.tx,spd);n.y=lerp(n.y,n.ty,spd);n.r=lerp(n.r,n.tr+n.flash*5,spd);n.alpha=lerp(n.alpha,n.talpha+n.flash*0.3,spd*0.7);n.color=lerpRgb(n.color,n.tcolor,spd);n.orbitAngle+=n.orbitSpeed*(isAI?0.15:1.2);n.flash*=0.91;if(n.flash<0.01)n.flash=0;}
      const dpr=window.devicePixelRatio||1;canvas.width=size*dpr;canvas.height=size*dpr;canvas.style.width=size+'px';canvas.style.height=size+'px';ctx.setTransform(dpr,0,0,dpr,0,0);
      render(ctx,nodes,conns,stars,isAI,time,scale,t);
      animRef.current=requestAnimationFrame(frame);
    }
    animRef.current=requestAnimationFrame(frame);
    return()=>{if(animRef.current)cancelAnimationFrame(animRef.current);};
  },[]);

  return React.createElement('canvas',{ref:canvasRef,style:{display:'block',borderRadius:Math.round(14*(size/600))+'px',width:size+'px',height:size+'px',border:'1px solid rgba(255,255,255,0.06)'}});
});


// ═══════════════════════════════════════════════════════
// 6 DRAMATICALLY DIFFERENT VARIATIONS
// ═══════════════════════════════════════════════════════
const VARIATIONS = [
  {
    name: 'v12 Production',
    desc: 'Current app. Aggregated blur clouds, all ghosts, full spread.',
    tag: 'ref',
    tuning: {},
  },
  {
    name: 'SVG Spirit',
    desc: 'Canvas recreation of the SVG feel. Only primaries, no force sim, per-primary glow, gentle drift.',
    tag: 'var',
    tuning: {
      primariesOnly: true,
      noForce: true,
      glowMode: 'perPrimary',
      glowRadius: 140,
      glowAlpha: 0.55,
      ghostAlpha: 0.12,
      answeredR: 14,
      answeredHalo: 50,
      driftMult: 1.6,
      secondHarmonic: 0.5,
      wobble: 6,
      breathAmp: 0.06,
      breathSpd: 0.2,
      noConnections: true,
      haloScale: 4,
      haloInner: 0.30,
      haloMid: 0.12,
      stars: 20,
    },
  },
  {
    name: 'Warm Glow',
    desc: 'Per-primary glow + companions + gentle force. Distinct color pools that overlap where primaries cluster.',
    tag: 'var',
    tuning: {
      glowMode: 'perPrimary',
      glowRadius: 130,
      glowAlpha: 0.45,
      ghostAlpha: 0.08,
      earnedCompanions: true,
      companionGhostAlpha: 0,
      driftMult: 1.2,
      secondHarmonic: 0.4,
      wobble: 5,
      breathAmp: 0.05,
      breathSpd: 0.25,
      connCurve: 18,
      connAlpha: 0.25,
      tightCluster: true,
      repulsionScale: 0.7,
      gravity: 0.06,
      stars: 40,
    },
  },
  {
    name: 'Tight Constellation',
    desc: 'Small compact cluster. Structural emphasis — thin connections, minimal glow, nodes prominent.',
    tag: 'var',
    tuning: {
      glowMode: 'perNode',
      glowRadius: 50,
      glowAlpha: 0.2,
      ghostAlpha: 0,
      earnedCompanions: true,
      companionGhostAlpha: 0,
      satThreshold: 8,
      tightCluster: true,
      repulsionScale: 0.4,
      gravity: 0.10,
      connAlpha: 0.4,
      connCurve: 10,
      connWidth: 0.7,
      haloScale: 2,
      answeredR: 10,
      stars: 60,
    },
  },
  {
    name: 'Living Nebula',
    desc: 'Per-node glow, every dot radiates. Rich color mixing where nodes overlap. Big, atmospheric.',
    tag: 'var',
    tuning: {
      glowMode: 'perNode',
      glowRadius: 100,
      glowAlpha: 0.4,
      ghostAlpha: 0.15,
      companionGhostAlpha: 0.1,
      companionAlpha: 0.7,
      driftMult: 1.4,
      secondHarmonic: 0.45,
      wobble: 5,
      breathAmp: 0.06,
      breathSpd: 0.2,
      connAlpha: 0.2,
      connCurve: 20,
      haloScale: 3.5,
      haloInner: 0.28,
      stars: 30,
    },
  },
  {
    name: 'Full Warmth',
    desc: 'The marriage: per-primary glow + earned presence + tight cluster + organic drift. SVG soul, canvas depth.',
    tag: 'var',
    tuning: {
      glowMode: 'perPrimary',
      glowRadius: 120,
      glowAlpha: 0.50,
      ghostAlpha: 0.06,
      earnedCompanions: true,
      companionGhostAlpha: 0,
      satThreshold: 8,
      tightCluster: true,
      repulsionScale: 0.6,
      gravity: 0.07,
      driftMult: 1.3,
      secondHarmonic: 0.45,
      wobble: 5,
      breathAmp: 0.05,
      breathSpd: 0.25,
      connCurve: 18,
      connAlpha: 0.28,
      haloScale: 3.5,
      haloInner: 0.26,
      haloMid: 0.10,
      stars: 30,
    },
  },
];


// ═══════════════════════════════════════════════════════
// HARNESS — Persona buttons + snapshot gallery
// ═══════════════════════════════════════════════════════

const ALL_ASSESS_IDS = [
  'starter-personality','starter-motivation','starter-thinking',
  'starter-connection','starter-strategy',
  'bigfive-E','integrity','shadow-M','adhd','attachment','risk',
];

function generateRandom(tier) {
  const answers={},assessments={};
  const entity=Math.random()<0.85?'human':'ai';
  const count=tier==='new'?(2+Math.floor(Math.random()*3)):10;
  const qOrder=[1,2,3,4,5,6,7,8,9,10].sort(()=>Math.random()-0.5);
  for(let i=0;i<count;i++) answers['onboard-'+qOrder[i]]=Math.random()<0.5?0:1;
  if(tier==='regular'){
    const n=2+Math.floor(Math.random()*3),sh=ALL_ASSESS_IDS.slice(0,5).sort(()=>Math.random()-0.5);
    for(let i=0;i<Math.min(n,sh.length);i++) assessments[sh[i]]={score:30+Math.floor(Math.random()*60)};
  } else if(tier==='power'){
    const n=5+Math.floor(Math.random()*4),sh=[...ALL_ASSESS_IDS].sort(()=>Math.random()-0.5);
    for(let i=0;i<Math.min(n,sh.length);i++) assessments[sh[i]]={score:20+Math.floor(Math.random()*70)};
  }
  return{answers,assessments,entity};
}

// Size scales with data depth
function sizeForTier(tier) {
  return tier === 'new' ? 180 : tier === 'regular' ? 240 : 300;
}

function App() {
  const [entityType,setEntityType]=React.useState('human');
  const [onboardingAnswers,setOnboardingAnswers]=React.useState({});
  const [assessCompleted,setAssessCompleted]=React.useState({});
  const [activeTier,setActiveTier]=React.useState(null);
  const [picked,setPicked]=React.useState(new Set());
  const [snapshots,setSnapshots]=React.useState([]);
  const [galleryVar,setGalleryVar]=React.useState(5);
  const [vizSize,setVizSize]=React.useState(240);

  function applyTier(tier) {
    const state=generateRandom(tier);
    setOnboardingAnswers(state.answers);
    setAssessCompleted(state.assessments);
    setEntityType(state.entity);
    setActiveTier(tier);
    setVizSize(sizeForTier(tier));
    setSnapshots(prev=>[{...state,tier,size:sizeForTier(tier)},...prev].slice(0,6));
  }

  function randomAll() {
    const tiers=['new','regular','power'];
    applyTier(tiers[Math.floor(Math.random()*3)]);
  }

  function togglePick(idx) {
    setPicked(prev=>{const next=new Set(prev);if(next.has(idx))next.delete(idx);else next.add(idx);return next;});
  }

  const ac=Object.keys(onboardingAnswers).length;
  const asc=Object.keys(assessCompleted).length;
  const label=activeTier==='new'?'New User':activeTier==='regular'?'Regular':activeTier==='power'?'Power User':'—';

  return React.createElement('div',{className:'page'},
    React.createElement('div',{className:'header'},
      React.createElement('h1',null,'Warm Canvas v2 — Per-Primary Glow'),
      React.createElement('p',null,`${label} · ${ac}/10 answers · ${asc} assessments · ${entityType} · ${vizSize}px`),
    ),

    React.createElement('div',{className:'controls'},
      React.createElement('button',{className:'ctrl-btn preset'+(activeTier==='new'?' active':''),onClick:()=>applyTier('new')},'New User'),
      React.createElement('button',{className:'ctrl-btn preset'+(activeTier==='regular'?' active':''),onClick:()=>applyTier('regular')},'Regular'),
      React.createElement('button',{className:'ctrl-btn preset'+(activeTier==='power'?' active':''),onClick:()=>applyTier('power')},'Power User'),
      React.createElement('button',{className:'ctrl-btn',onClick:randomAll,style:{borderColor:'#8b5cf6',color:'#8b5cf6',fontWeight:600}},'Random'),
    ),

    picked.size>0&&React.createElement('div',{className:'pick-bar'},
      React.createElement('span',null,`Favorites: ${[...picked].map(i=>VARIATIONS[i].name).join(', ')}`),
    ),

    React.createElement('div',{className:'grid'},
      VARIATIONS.map((v,idx)=>
        React.createElement('div',{key:idx,className:'cell'+(picked.has(idx)?' picked':''),onClick:()=>togglePick(idx)},
          React.createElement('div',{style:{display:'flex',gap:'8px',alignItems:'center'}},
            React.createElement('span',{className:'cell-label'},v.name),
            React.createElement('span',{className:'cell-tag '+(v.tag==='ref'?'tag-ref':'tag-var')},v.tag==='ref'?'baseline':'variation'),
          ),
          React.createElement('div',{className:'cell-desc'},v.desc),
          React.createElement(WarmAuraViz,{onboardingAnswers,assessCompleted,entityType,darkMode:true,size:vizSize,tuning:v.tuning}),
        ),
      ),
    ),

    snapshots.length>0&&React.createElement(React.Fragment,null,
      React.createElement('div',{className:'divider'}),
      React.createElement('div',{className:'section-label'},`Recent (${VARIATIONS[galleryVar].name})`),
      React.createElement('div',{className:'controls',style:{marginBottom:'6px'}},
        VARIATIONS.map((v,idx)=>
          React.createElement('button',{key:idx,className:'ctrl-btn'+(galleryVar===idx?' active':''),onClick:()=>setGalleryVar(idx),style:{padding:'3px 8px',fontSize:'9px'}},v.name),
        ),
      ),
      React.createElement('div',{style:{display:'flex',gap:'10px',justifyContent:'center',flexWrap:'wrap'}},
        snapshots.map((snap,i)=>
          React.createElement('div',{key:i,style:{display:'flex',flexDirection:'column',alignItems:'center',gap:'3px',opacity:i===0?1:0.6+i*0.05}},
            React.createElement('div',{style:{borderRadius:'8px',overflow:'hidden',border:i===0?'2px solid rgba(139,92,246,0.4)':'1px solid rgba(255,255,255,0.06)'}},
              React.createElement(WarmAuraViz,{onboardingAnswers:snap.answers,assessCompleted:snap.assessments,entityType:snap.entity,darkMode:true,size:snap.size*0.45,tuning:VARIATIONS[galleryVar].tuning}),
            ),
            React.createElement('div',{style:{fontSize:'8px',color:'#6b7280',textTransform:'uppercase',letterSpacing:'0.08em'}},
              `${snap.tier} · ${Object.keys(snap.answers).length}q · ${Object.keys(snap.assessments).length}a`
            ),
          ),
        ),
      ),
    ),
  );
}

const root=ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(App));
</script>
</body>
</html>