<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aura Design Playground v2</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }

    @keyframes shimmer-pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.8; } }
    @keyframes fadeSlideIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes sweepFill { from { width: 0%; } to { width: 100%; } }
    @keyframes celebrateGlow { 0% { transform: scale(0.8); opacity: 0; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
    .celebrate-glow { animation: celebrateGlow 0.6s ease-out forwards; }

    .shine-card { position: relative; }
    .shine-card::before {
      content: ''; position: absolute; inset: -1px; border-radius: inherit;
      background: linear-gradient(180deg, var(--accent-bright, rgba(255,255,255,0.5)) 0%, var(--accent-color, rgba(255,255,255,0.2)) 5%, transparent 15%, transparent 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
      padding: 2px; pointer-events: none; z-index: 20; opacity: 0; transition: opacity 0.3s ease;
    }
    .shine-card:hover::before { opacity: 1; animation: shimmer-pulse 3s ease-in-out infinite; }

    .shine-emerald { --accent-color: rgba(16, 185, 129, 0.25); --accent-bright: rgba(110, 231, 183, 0.55); }
    .shine-rose { --accent-color: rgba(244, 63, 94, 0.25); --accent-bright: rgba(251, 113, 133, 0.55); }
    .shine-violet { --accent-color: rgba(139, 92, 246, 0.25); --accent-bright: rgba(196, 181, 253, 0.55); }
    .shine-blue { --accent-color: rgba(59, 130, 246, 0.3); --accent-bright: rgba(147, 197, 253, 0.6); }

    .glow-amber { box-shadow: 0 0 15px rgba(251, 191, 36, 0.12), 0 0 35px rgba(251, 191, 36, 0.08); }
    .glow-violet { box-shadow: 0 0 18px rgba(139, 92, 246, 0.2), 0 0 40px rgba(139, 92, 246, 0.12); }
    .glow-teal { box-shadow: 0 0 18px rgba(45, 212, 191, 0.16), 0 0 40px rgba(45, 212, 191, 0.1); }

    .btn-feedback { transition: transform 0.1s ease, filter 0.1s ease; }
    .btn-feedback:hover { filter: brightness(1.15); }
    .btn-feedback:active { transform: scale(0.96); filter: brightness(0.92); }

    .question-text { font-size: clamp(18px, 5vw, 24px); line-height: 1.35; text-wrap: balance; }
    .hide-scrollbar::-webkit-scrollbar { display: none; }
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

    input[type="color"] { -webkit-appearance: none; border: none; width: 32px; height: 32px; cursor: pointer; border-radius: 4px; }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState } = React;

// ============================================================
// CANONICAL CONFIDENCE BAR (synced from index.html)
// This is the production implementation used across the app.
// Design: checkmark inside user's segment, overlay highlight with matching border-radius
// ============================================================
const renderConfidenceBar = (byConf, colors, maxCount, isUser, userConf, height = 'h-5', darkMode = true) => {
  const totalCount = byConf.reduce((a, b) => a + b, 0);
  if (totalCount === 0) return <div className={`flex-1 ${height} rounded-full`} style={{ border: `1px solid ${colors[0]}40` }} />;

  // Build segments array (high conf first: 3,2,1,0)
  const segments = [];
  for (let i = 3; i >= 0; i--) {
    if (byConf[i] > 0) segments.push({ width: (byConf[i] / maxCount) * 100, color: colors[i], conf: i });
  }
  const totalWidth = segments.reduce((a, s) => a + s.width, 0);
  const showEmpty = (100 - totalWidth) > 2;

  // Text color for checkmark: dark text on light segments (conf 0,1), white on dark (conf 2,3)
  const getCheckColor = (conf) => conf <= 1 ? '#374151' : 'white';
  // Highlight color: white in dark mode, gray-500 in light mode
  const highlightColor = darkMode ? 'white' : '#6b7280';

  return (
    <div className={`flex-1 ${height} rounded-full overflow-hidden flex`} style={{ border: showEmpty ? `1px solid ${colors[0]}40` : 'none' }}>
      {segments.map((s, i) => {
        const isUserSeg = isUser && s.conf === userConf;
        const isLast = i === segments.length - 1;
        const isFirst = i === 0;
        // Border-radius for highlight overlay (matches segment position)
        const segRadius = isFirst && isLast ? '9999px' : isFirst ? '9999px 0 0 9999px' : isLast ? '0 9999px 9999px 0' : '0';

        return (
          <div key={i} className={`h-full relative flex items-center justify-center ${isLast ? 'rounded-r-full' : ''} ${isFirst ? 'rounded-l-full' : ''}`} style={{
            width: showEmpty ? `${s.width}%` : (isLast ? undefined : `${s.width}%`),
            flex: !showEmpty && isLast ? 1 : undefined,
            backgroundColor: s.color,
          }}>
            {isUserSeg && (
              <>
                <span className="text-xs font-black relative z-10" style={{ color: getCheckColor(s.conf) }}>‚úì</span>
                <div className="absolute inset-0 pointer-events-none" style={{
                  borderRadius: segRadius,
                  boxShadow: `inset 0 0 0 3px ${highlightColor}`,
                }} />
              </>
            )}
          </div>
        );
      })}
    </div>
  );
};

// ============================================================
// THEME & DATA (same as v1)
// ============================================================
const PALETTES = {
  aura: {
    name: 'Aura (Current)',
    colors: { primary: '#8b5cf6', secondary: '#3b82f6', success: '#10b981', danger: '#f43f5e', warning: '#f59e0b', neutral: '#6b7280' },
    categories: { prediction: '#fbbf24', reasoning: '#8b5cf6', judgment: '#14b8a6' },
    confidence: { yes: ['#a7f3d0', '#6ee7b7', '#34d399', '#10b981'], no: ['#fecaca', '#fda4af', '#fb7185', '#f43f5e'] },
  },
};

const buildTheme = (palette) => ({
  ...palette,
  assessments: { rose: '#f43f5e', indigo: '#6366f1', blue: '#3b82f6', violet: '#8b5cf6', emerald: '#10b981', slate: '#64748b', pink: '#ec4899' },
  mcColors: [
    { name: 'blue', hex: '#3b82f6', shades: ['#bfdbfe', '#93c5fd', '#3b82f6', '#1d4ed8'] },
    { name: 'teal', hex: '#14b8a6', shades: ['#99f6e4', '#5eead4', '#2dd4bf', '#14b8a6'] },
    { name: 'emerald', hex: '#10b981', shades: ['#a7f3d0', '#6ee7b7', '#34d399', '#10b981'] },
    { name: 'rose', hex: '#f43f5e', shades: ['#fecaca', '#fda4af', '#fb7185', '#f43f5e'] },
    { name: 'violet', hex: '#8b5cf6', shades: ['#ddd6fe', '#c4b5fd', '#a78bfa', '#8b5cf6'] },
  ],
});

const DEFAULT_THEME = buildTheme(PALETTES.aura);

const SAMPLE_QUESTIONS = [
  { id: 1, type: 'binary', category: 'prediction', text: 'Will AI surpass human intelligence by 2030?', evidence: [{ type: 'stat', label: 'Expert consensus', value: '45% likely' }] },
  { id: 2, type: 'multiple', category: 'reasoning', text: 'Is a hot dog a sandwich?', options: ['Yes, bread with filling', 'No, its own category', "It's a taco", 'Depends on definition'] },
];

const SAMPLE_ASSESSMENTS = [
  { id: 'quick-profile', name: 'Quick Profile', icon: '‚ú®', color: 'rose', items: 10 },
  { id: 'starter-personality', name: 'Personality', icon: 'ü™û', color: 'indigo', items: 9 },
  { id: 'bigfive-E', name: 'Extraversion', icon: 'üé≠', color: 'violet', items: 10 },
  { id: 'adhd', name: 'ADHD Screener', icon: 'üß†', color: 'blue', items: 6 },
];

const SAMPLE_VOTES = {
  binary: [
    { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 },
    { answer: 0, confidence: 2 }, { answer: 0, confidence: 2 }, { answer: 0, confidence: 2 },
    { answer: 0, confidence: 1 }, { answer: 0, confidence: 1 },
    { answer: 1, confidence: 4 }, { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 },
    { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 }, { answer: 1, confidence: 1 },
  ],
  multiple: [
    { answer: 0, confidence: 3 }, { answer: 0, confidence: 2 }, { answer: 0, confidence: 4 },
    { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 }, { answer: 1, confidence: 3 },
    { answer: 1, confidence: 2 }, { answer: 1, confidence: 2 }, { answer: 1, confidence: 1 },
    { answer: 2, confidence: 3 }, { answer: 2, confidence: 2 },
    { answer: 3, confidence: 4 }, { answer: 3, confidence: 1 },
  ],
};

const CATEGORIES = [
  { id: 'prediction', name: 'Predictions', icon: 'üîÆ', color: 'amber', count: 45 },
  { id: 'reasoning', name: 'Reasoning', icon: 'üß†', color: 'violet', count: 52 },
  { id: 'judgment', name: 'Judgment', icon: '‚öñÔ∏è', color: 'teal', count: 30 },
];

const DEVICES = {
  'iphone-se': { name: 'iPhone SE', width: 375, height: 667, scale: 1 },
  'iphone-15': { name: 'iPhone 15', width: 393, height: 852, scale: 1 },
};

// ============================================================
// HELPERS
// ============================================================
const TH = (type, darkMode) => {
  const themes = {
    'text-primary': darkMode ? 'text-white' : 'text-gray-900',
    'text-muted': darkMode ? 'text-gray-400' : 'text-gray-500',
    'text-subtle': darkMode ? 'text-gray-500' : 'text-gray-400',
    'bg-card': darkMode ? 'bg-gray-900' : 'bg-white',
  };
  return themes[type] || '';
};

const hexToRgb = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0,0,0';
};

const getStars = (n) => '‚òÖ'.repeat(Math.min(n, 4));

// ============================================================
// CORE COMPONENTS (unchanged from v1)
// ============================================================
const ConfidenceSegments = ({ level, color = 'emerald', active = false, theme }) => {
  const colors = { emerald: theme.confidence.yes, rose: theme.confidence.no };
  const shades = colors[color] || colors.emerald;
  if (!active || level === 0) return null;
  return (
    <div className="absolute bottom-0 left-0 right-0 h-2 flex">
      {[1, 2, 3, 4].map(i => (
        <div key={i} className={`flex-1 transition-all duration-150 ${i === 1 ? 'rounded-bl-xl' : ''} ${i === 4 ? 'rounded-br-xl' : ''}`}
          style={{ backgroundColor: level >= i ? shades[i - 1] : 'rgba(0,0,0,0.2)', borderRight: i < 4 ? '1px solid rgba(0,0,0,0.3)' : 'none' }} />
      ))}
    </div>
  );
};

const CategoryChip = ({ category, theme, darkMode }) => {
  const catConfig = { prediction: { name: 'Predictions', icon: 'üîÆ' }, reasoning: { name: 'Reasoning', icon: 'üß†' }, judgment: { name: 'Judgment', icon: '‚öñÔ∏è' } };
  const cat = catConfig[category];
  const color = theme.categories[category];
  if (!cat) return null;
  return <span className="px-2 py-0.5 rounded-full text-sm font-medium" style={{ backgroundColor: darkMode ? `${color}20` : `${color}15`, color }}>{cat.icon} {cat.name}</span>;
};

const BinaryButtons = ({ darkMode, theme, selectedAnswer, confidence, onSelect }) => {
  const getButtonStyle = (answer) => {
    const isSelected = selectedAnswer === answer;
    const shades = answer === 0 ? theme.confidence.yes : theme.confidence.no;
    const conf = confidence || 2;
    if (isSelected) {
      return { background: `linear-gradient(135deg, ${shades[conf - 1]} 0%, ${shades[Math.min(conf, 3)]} 100%)`, boxShadow: `0 0 ${conf * 8}px rgba(${hexToRgb(shades[3])}, ${0.2 + conf * 0.15})`, color: 'white' };
    }
    return { background: darkMode ? 'rgb(31,41,55)' : 'rgb(255,255,255)', color: darkMode ? 'rgb(209,213,219)' : (answer === 0 ? theme.colors.success : theme.colors.danger) };
  };
  return (
    <div className="grid grid-cols-2 gap-3">
      {[0, 1].map(answer => (
        <button key={answer} onClick={() => onSelect(answer)}
          className={`relative h-14 rounded-xl font-bold overflow-hidden select-none btn-feedback ${selectedAnswer === answer ? (answer === 0 ? 'ring-2 ring-emerald-400 shine-card shine-emerald' : 'ring-2 ring-rose-400 shine-card shine-rose') : ''}`}
          style={getButtonStyle(answer)}>
          <ConfidenceSegments level={confidence} color={answer === 0 ? 'emerald' : 'rose'} active={selectedAnswer === answer} theme={theme} />
          <div className="relative z-10 flex items-center justify-center h-full">
            <span className="text-xl font-bold">{answer === 0 ? 'YES' : 'NO'}</span>
          </div>
        </button>
      ))}
    </div>
  );
};

const NavBar = ({ darkMode, theme, stats }) => (
  <div className={`flex items-center justify-between px-4 py-2 ${darkMode ? 'bg-gray-950/70 border-b border-white/5' : 'bg-white/70 border-b border-gray-200/50'} backdrop-blur-md`}>
    <button className="text-xl btn-feedback">üåÄ</button>
    <div className="flex items-center gap-2">
      <span className={`text-sm ${TH('text-muted', darkMode)}`}>{stats.answered} answered</span>
      {stats.streak > 0 && <span className="text-sm text-orange-400">üî•{stats.streak}</span>}
    </div>
    <button className={`text-xl btn-feedback ${TH('text-muted', darkMode)}`}>‚ò∞</button>
  </div>
);

const ProgressCircle = ({ progress = 0, size = 48, strokeWidth = 3, color, darkMode, icon }) => {
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const gradId = `prog-${Math.random().toString(36).substr(2, 9)}`;
  return (
    <div className="relative flex items-center justify-center" style={{ width: size, height: size }}>
      {progress > 0 && <div className="absolute inset-0 rounded-full blur-md opacity-40" style={{ background: color }} />}
      <svg width={size} height={size} className="absolute">
        <defs><linearGradient id={gradId} x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stopColor={progress > 0 ? color : '#374151'} /><stop offset="100%" stopColor={progress > 0 ? color : '#4b5563'} /></linearGradient></defs>
        <circle cx={size/2} cy={size/2} r={radius} fill="none" stroke={darkMode ? '#1f2937' : '#e5e7eb'} strokeWidth={strokeWidth} />
        <circle cx={size/2} cy={size/2} r={radius} fill="none" stroke={`url(#${gradId})`} strokeWidth={strokeWidth} strokeLinecap="round" strokeDasharray={circumference} strokeDashoffset={circumference * (1 - progress / 100)} transform={`rotate(-90 ${size/2} ${size/2})`} className="transition-all duration-500" />
      </svg>
      {icon && <span className="relative z-10 text-lg">{icon}</span>}
    </div>
  );
};

// ============================================================
// FIXED: Assessment Card WITHOUT left border accent
// ============================================================
const AssessmentCard = ({ assessment, darkMode, theme, progress = 0, onClick }) => {
  const colorHex = theme.assessments[assessment.color] || theme.colors.primary;
  return (
    <div onClick={onClick}
      className={`p-4 rounded-xl flex items-center gap-3 btn-feedback cursor-pointer mb-2 ${darkMode ? 'bg-gray-900 hover:bg-gray-800' : 'bg-white hover:bg-gray-50 border border-gray-200'}`}>
      <ProgressCircle progress={progress} size={44} color={colorHex} darkMode={darkMode} icon={assessment.icon} />
      <div className="flex-1">
        <div className={`font-medium ${TH('text-primary', darkMode)}`}>{assessment.name}</div>
        <div className={`text-sm ${TH('text-muted', darkMode)}`}>{assessment.items} questions</div>
      </div>
      <span className={TH('text-subtle', darkMode)}>‚Üí</span>
    </div>
  );
};

// ============================================================
// FIXED: Category Browser WITHOUT left border accents
// ============================================================
const CategoryBrowserScreen = ({ darkMode, theme }) => (
  <div className={`flex-1 flex flex-col ${darkMode ? 'bg-gray-950' : 'bg-gray-50'}`}>
    <NavBar darkMode={darkMode} theme={theme} stats={{ answered: 42, streak: 5 }} />
    <div className="flex-1 overflow-auto p-4">
      <h2 className={`text-lg font-semibold mb-4 ${TH('text-primary', darkMode)}`}>Browse by Category</h2>
      <div className="space-y-3">
        {CATEGORIES.map(cat => {
          const colorMap = { amber: '#f59e0b', violet: '#8b5cf6', teal: '#14b8a6' };
          const color = colorMap[cat.color] || theme.colors.primary;
          return (
            <button key={cat.id}
              className={`w-full p-4 rounded-xl flex items-center gap-4 btn-feedback ${darkMode ? 'bg-gray-900 hover:bg-gray-800' : 'bg-white hover:bg-gray-50 border border-gray-200'}`}>
              {/* Icon with subtle color background - NO left border */}
              <div className="w-12 h-12 rounded-xl flex items-center justify-center text-2xl" style={{ background: `${color}20` }}>
                {cat.icon}
              </div>
              <div className="flex-1 text-left">
                <div className={`font-medium ${TH('text-primary', darkMode)}`}>{cat.name}</div>
                <div className={`text-sm ${TH('text-muted', darkMode)}`}>{cat.count} questions</div>
              </div>
              <span className={`${TH('text-subtle', darkMode)}`}>‚Üí</span>
            </button>
          );
        })}
      </div>
      <div className="mt-6">
        <h3 className={`text-sm font-medium mb-3 ${TH('text-muted', darkMode)}`}>Assessments</h3>
        {SAMPLE_ASSESSMENTS.slice(0, 3).map((a, i) => (
          <AssessmentCard key={a.id} assessment={a} darkMode={darkMode} theme={theme} progress={i === 0 ? 100 : i === 1 ? 45 : 0} />
        ))}
      </div>
    </div>
  </div>
);

// ============================================================
// NEW: Assessment Complete with Results Tease + Navigation
// ============================================================
const CompleteModalEnhanced = ({ darkMode, theme, assessmentName = 'Quick Profile', onViewResults, onNextAssessment, onExplore }) => {
  // Sample result tease data
  const resultTease = {
    topTrait: 'Openness',
    topScore: 81,
    insight: "You're highly curious and open to new experiences",
  };

  return (
    <div className="absolute inset-0 flex items-center justify-center z-40 p-4">
      <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />
      <div className={`relative z-50 w-full max-w-xs rounded-2xl p-5 ${darkMode ? 'bg-gray-900' : 'bg-white'}`} style={{boxShadow: `0 0 60px ${theme.colors.success}30`}}>
        {/* Success header */}
        <div className="text-center mb-4">
          <div className="text-4xl mb-2 celebrate-glow">‚ú®</div>
          <h2 className={`text-xl font-bold ${TH('text-primary', darkMode)}`}>Complete!</h2>
          <p className={`text-sm ${TH('text-muted', darkMode)}`}>{assessmentName}</p>
          <div className="flex items-center justify-center gap-2 mt-2">
            <span className="text-lg font-bold" style={{color: theme.colors.success}}>+50 XP</span>
          </div>
        </div>

        {/* Results tease */}
        <div className={`rounded-xl p-4 mb-4 ${darkMode ? 'bg-gray-800' : 'bg-gray-100'}`}>
          <div className={`text-xs font-medium mb-2 ${TH('text-muted', darkMode)}`}>Your top trait</div>
          <div className="flex items-center justify-between mb-2">
            <span className={`font-bold ${TH('text-primary', darkMode)}`}>{resultTease.topTrait}</span>
            <span className="font-bold" style={{ color: theme.colors.primary }}>{resultTease.topScore}%</span>
          </div>
          <div className={`h-2 rounded-full mb-3 ${darkMode ? 'bg-gray-700' : 'bg-gray-200'}`}>
            <div className="h-full rounded-full" style={{ width: `${resultTease.topScore}%`, background: `linear-gradient(90deg, ${theme.colors.primary}, ${theme.colors.secondary})` }} />
          </div>
          <p className={`text-sm ${TH('text-muted', darkMode)}`}>{resultTease.insight}</p>
        </div>

        {/* Action buttons - Next Assessment is primary CTA */}
        <div className="space-y-3">
          <button onClick={onNextAssessment} className="w-full py-3.5 rounded-xl font-semibold text-white btn-feedback" style={{background: theme.colors.primary}}>
            Next Assessment ‚Üí
          </button>
          <div className="grid grid-cols-2 gap-2">
            <button onClick={onExplore} className={`py-2 rounded-lg text-xs font-medium btn-feedback ${darkMode ? 'bg-gray-800/60 text-gray-400 hover:text-gray-300' : 'bg-gray-200 text-gray-600'}`}>
              Explore Questions
            </button>
            <button onClick={onViewResults} className={`py-2 rounded-lg text-xs font-medium btn-feedback ${darkMode ? 'bg-gray-800/60 text-gray-400 hover:text-gray-300' : 'bg-gray-200 text-gray-600'}`}>
              View Full Results
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// ============================================================
// CHART EXPERIMENTS - Multiple variations to test
// ============================================================

// ============================================================
// BINARY CHART VARIATIONS - All keep confidence segments, vary "You" indicator
// ============================================================

// Helper to build binary chart data
const buildBinaryData = (votes, userResponse, theme) => {
  const yesColors = theme.confidence.yes;
  const noColors = theme.confidence.no;
  const data = [{ label: 'Yes', answer: 0, confCounts: [0,0,0,0] }, { label: 'No', answer: 1, confCounts: [0,0,0,0] }];
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  allVotes.forEach(v => { if (v.answer === 0) data[0].confCounts[v.confidence - 1]++; else if (v.answer === 1) data[1].confCounts[v.confidence - 1]++; });
  data.forEach(d => d.count = d.confCounts.reduce((a, b) => a + b, 0));
  const total = data[0].count + data[1].count;
  const sorted = [...data].sort((a, b) => b.count - a.count);
  const maxCount = Math.max(data[0].count, data[1].count, 1);
  return { data, sorted, total, maxCount, yesColors, noColors };
};

// Render confidence bar segments
const renderConfBar = (opt, colors, barWidth, darkMode) => (
  <div className={`h-5 rounded-full overflow-hidden ${darkMode ? 'bg-gray-800' : 'bg-gray-200'}`}>
    <div className="h-full flex" style={{ width: `${barWidth}%` }}>
      {[3, 2, 1, 0].map(confIdx => {
        const count = opt.confCounts[confIdx];
        if (count === 0) return null;
        const segWidth = (count / opt.count) * 100;
        return <div key={confIdx} className="h-full" style={{ width: `${segWidth}%`, background: colors[confIdx] }} />;
      })}
    </div>
  </div>
);

// CURRENT: Original design (baseline) - matches real app with white outline on user's segment
const BinaryChartCurrent = ({ votes, userResponse, darkMode, theme, label = 'Current Design' }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>{label}</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <span className={`text-sm font-medium ${isUserRow ? 'px-2 py-0.5 rounded-full border' : ''}`} style={{ color: colors[3], borderColor: isUserRow ? colors[3] : 'transparent' }}>
                {opt.label} {isUserRow && '(You)'}
              </span>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// Helper: render bar with user's confidence segment highlighted
const renderConfBarWithUser = (opt, colors, barWidth, darkMode, userConf, isUserRow, highlightStyle = 'outline') => {
  return (
    <div className={`h-5 rounded-full overflow-hidden ${darkMode ? 'bg-gray-800' : 'bg-gray-200'}`}>
      <div className="h-full flex" style={{ width: `${barWidth}%` }}>
        {[3, 2, 1, 0].map(confIdx => {
          const count = opt.confCounts[confIdx];
          if (count === 0) return null;
          const segWidth = (count / opt.count) * 100;
          const isUserSeg = isUserRow && confIdx === userConf;

          let segStyle = { width: `${segWidth}%`, background: colors[confIdx] };
          if (isUserSeg) {
            if (highlightStyle === 'outline') {
              segStyle.boxShadow = 'inset 0 0 0 2px white';
            } else if (highlightStyle === 'glow') {
              segStyle.boxShadow = `inset 0 0 0 2px white, 0 0 8px ${colors[confIdx]}`;
            } else if (highlightStyle === 'bright') {
              segStyle.filter = 'brightness(1.3)';
              segStyle.boxShadow = 'inset 0 0 0 2px white';
            }
          }
          return <div key={confIdx} className="h-full relative" style={segStyle}>
            {isUserSeg && highlightStyle === 'dot' && (
              <div className="absolute -bottom-1.5 left-1/2 -translate-x-1/2 w-2 h-2 rounded-full bg-white border-2" style={{ borderColor: colors[3] }} />
            )}
            {isUserSeg && highlightStyle === 'arrow' && (
              <div className="absolute -top-2 left-1/2 -translate-x-1/2 text-white text-xs">‚ñº</div>
            )}
          </div>;
        })}
      </div>
    </div>
  );
};

// Confidence level labels
const confLabels = ['Unsure', 'Leaning', 'Confident', 'Very sure'];

// V1a: Pill + white outline on confidence segment
const BinaryChartV1 = ({ votes, userResponse, darkMode, theme }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1a: Pill + outline on segment</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium" style={{ color: colors[3] }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium" style={{ background: colors[3] }}>You</span>}
              </div>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// V1e: Pill shows confidence level text
const BinaryChartV5 = ({ votes, userResponse, darkMode, theme }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1e: Pill with confidence text</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium" style={{ color: colors[3] }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium" style={{ background: colors[3] }}>You ‚Ä¢ {confLabels[userConf]}</span>}
              </div>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// V1f: Pill shows stars for confidence
const BinaryChartV6 = ({ votes, userResponse, darkMode, theme }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1f: Pill with stars</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium" style={{ color: colors[3] }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium" style={{ background: colors[3] }}>You {getStars(userConf + 1)}</span>}
              </div>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// V1h: Bright highlighted segment + pill
const BinaryChartV8 = ({ votes, userResponse, darkMode, theme }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1h: Pill + bright segment</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium" style={{ color: colors[3] }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium" style={{ background: colors[3] }}>You</span>}
              </div>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'bright')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// ============================================================
// BOLD VARIATIONS - User choice is much more prominent
// ============================================================

// BOLD1: Full row background highlight
const BinaryChartBold1 = ({ votes, userResponse, darkMode, theme }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-2">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Bold 1: Full row background</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer}
            className={`p-3 -mx-3 rounded-xl transition-all ${isUserRow ? 'ring-2' : ''}`}
            style={{
              background: isUserRow ? `${colors[3]}15` : 'transparent',
              ringColor: isUserRow ? colors[3] : 'transparent'
            }}>
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-2">
                <span className="text-sm font-semibold" style={{ color: colors[3] }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2.5 py-1 rounded-full text-white font-bold" style={{ background: colors[3] }}>YOU</span>}
              </div>
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'bright')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// ============================================================
// INLINE "YOU" VARIATIONS - Text inside the confidence segment
// ============================================================

// Helper: render bar with checkmark inside the user's confidence segment
const renderConfBarInline = (opt, colors, barWidth, darkMode, userConf, isUserRow) => {
  // Light segments (confIdx 0,1) need dark text; dark segments (confIdx 2,3) need white text
  const getTextColor = (confIdx) => confIdx <= 1 ? '#374151' : 'white';

  // Figure out which segments exist to determine first/last
  const existingSegments = [3, 2, 1, 0].filter(idx => opt.confCounts[idx] > 0);
  const firstSeg = existingSegments[0];
  const lastSeg = existingSegments[existingSegments.length - 1];

  // Highlight styling
  const highlightColor = darkMode ? 'white' : '#6b7280'; // gray-500 for light
  const barBg = darkMode ? 'bg-gray-800' : 'bg-gray-200';

  return (
    <div className={`h-7 rounded-full ${barBg} relative`}>
      {/* Bar segments with highlight overlay inside */}
      <div className="h-full flex rounded-full overflow-hidden relative" style={{ width: `${barWidth}%` }}>
        {[3, 2, 1, 0].map(confIdx => {
          const count = opt.confCounts[confIdx];
          if (count === 0) return null;
          const segWidth = (count / opt.count) * 100;
          const isUserSeg = isUserRow && confIdx === userConf;
          const textColor = getTextColor(confIdx);

          // Determine border-radius for this segment's highlight
          const isFirst = confIdx === firstSeg;
          const isLast = confIdx === lastSeg;
          const segRadius = isFirst && isLast ? '14px' :
                            isFirst ? '14px 0 0 14px' :
                            isLast ? '0 14px 14px 0' : '0';

          return (
            <div key={confIdx} className="h-full relative flex items-center justify-center"
              style={{
                width: `${segWidth}%`,
                background: colors[confIdx],
              }}>
              {isUserSeg && (
                <>
                  <span className="text-sm font-black px-1 relative z-10" style={{ color: textColor }}>‚úì</span>
                  {/* Highlight ring overlay */}
                  <div className="absolute inset-0 pointer-events-none"
                    style={{
                      borderRadius: segRadius,
                      boxShadow: `inset 0 0 0 3px ${highlightColor}`,
                    }}
                  />
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

// Helper: render answer label with pill outline when user's answer
const renderAnswerLabel = (label, isUserRow, color, darkMode) => {
  if (isUserRow) {
    return (
      <span className="text-sm font-semibold px-3 py-1 rounded-full border-2"
        style={{ color, borderColor: color }}>
        {label}
      </span>
    );
  }
  return <span className="text-sm font-medium" style={{ color }}>{label}</span>;
};

// Sample data for different scenarios
const VOTES_USER_MAJORITY_HIGH = [
  // Yes votes - user is here with high confidence (big segment)
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 },
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 2 }, { answer: 0, confidence: 1 },
  // No votes
  { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 }, { answer: 1, confidence: 1 },
];

const VOTES_USER_MAJORITY_LOW = [
  // Yes votes - user is here with low confidence (small segment)
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 2 },
  { answer: 0, confidence: 2 }, { answer: 0, confidence: 1 },
  // No votes
  { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 },
];

const VOTES_USER_MINORITY_HIGH = [
  // Yes votes (majority)
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 2 }, { answer: 0, confidence: 2 }, { answer: 0, confidence: 1 },
  // No votes - user is here with high confidence
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 4 },
  { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 },
];

const VOTES_USER_MINORITY_LOW = [
  // Yes votes (majority)
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 3 }, { answer: 0, confidence: 2 }, { answer: 0, confidence: 2 },
  { answer: 0, confidence: 1 }, { answer: 0, confidence: 1 },
  // No votes - user is here with low confidence (tiny segment)
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 }, { answer: 1, confidence: 1 },
];

// Parameterized inline chart for testing different highlight colors
const BinaryChartInlineWithColor = ({ darkMode, theme, votes, userResponse, label, lightHighlight }) => {
  const { sorted, total, maxCount, yesColors, noColors } = buildBinaryData(votes, userResponse, theme);
  const userConf = userResponse.confidence - 1;

  // Custom render with specific highlight color
  const renderBarWithHighlight = (opt, colors, barWidth, isUserRow) => {
    const getTextColor = (confIdx) => confIdx <= 1 ? '#374151' : 'white';
    const existingSegments = [3, 2, 1, 0].filter(idx => opt.confCounts[idx] > 0);
    const firstSeg = existingSegments[0];
    const lastSeg = existingSegments[existingSegments.length - 1];
    const highlightColor = darkMode ? 'white' : lightHighlight;
    const barBg = darkMode ? 'bg-gray-800' : 'bg-gray-200';

    return (
      <div className={`h-7 rounded-full ${barBg} relative`}>
        <div className="h-full flex rounded-full overflow-hidden relative" style={{ width: `${barWidth}%` }}>
          {[3, 2, 1, 0].map(confIdx => {
            const count = opt.confCounts[confIdx];
            if (count === 0) return null;
            const segWidth = (count / opt.count) * 100;
            const isUserSeg = isUserRow && confIdx === userConf;
            const textColor = getTextColor(confIdx);
            const isFirst = confIdx === firstSeg;
            const isLast = confIdx === lastSeg;
            const segRadius = isFirst && isLast ? '14px' : isFirst ? '14px 0 0 14px' : isLast ? '0 14px 14px 0' : '0';

            return (
              <div key={confIdx} className="h-full relative flex items-center justify-center" style={{ width: `${segWidth}%`, background: colors[confIdx] }}>
                {isUserSeg && (
                  <>
                    <span className="text-sm font-black px-1 relative z-10" style={{ color: textColor }}>‚úì</span>
                    <div className="absolute inset-0 pointer-events-none" style={{ borderRadius: segRadius, boxShadow: `inset 0 0 0 3px ${highlightColor}` }} />
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>{label}</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = opt.answer === 0 ? yesColors : noColors;
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              {renderAnswerLabel(opt.label, isUserRow, colors[3], darkMode)}
              <span className="text-sm font-bold" style={{ color: colors[3] }}>{pct}%</span>
            </div>
            {renderBarWithHighlight(opt, colors, barWidth, isUserRow)}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// INLINE1: Majority + High Confidence
const BinaryChartInline1 = ({ darkMode, theme }) => (
  <BinaryChartInlineWithColor
    darkMode={darkMode} theme={theme}
    votes={VOTES_USER_MAJORITY_HIGH}
    userResponse={{ answer: 0, confidence: 4 }}
    label="Majority answer, high confidence"
    lightHighlight="#6b7280"
  />
);

// INLINE2: Majority + Low Confidence
const BinaryChartInline2 = ({ darkMode, theme }) => (
  <BinaryChartInlineWithColor
    darkMode={darkMode} theme={theme}
    votes={VOTES_USER_MAJORITY_LOW}
    userResponse={{ answer: 0, confidence: 1 }}
    label="Majority answer, low confidence"
    lightHighlight="#6b7280"
  />
);

// INLINE3: Minority + High Confidence
const BinaryChartInline3 = ({ darkMode, theme }) => (
  <BinaryChartInlineWithColor
    darkMode={darkMode} theme={theme}
    votes={VOTES_USER_MINORITY_HIGH}
    userResponse={{ answer: 1, confidence: 4 }}
    label="Minority answer, high confidence"
    lightHighlight="#6b7280"
  />
);

// INLINE4: Minority + Low Confidence
const BinaryChartInline4 = ({ darkMode, theme }) => (
  <BinaryChartInlineWithColor
    darkMode={darkMode} theme={theme}
    votes={VOTES_USER_MINORITY_LOW}
    userResponse={{ answer: 1, confidence: 1 }}
    label="Minority answer, low confidence"
    lightHighlight="#6b7280"
  />
);

// ============================================================
// MC INLINE CHARTS - Same design as binary
// ============================================================

// MC sample vote data for different scenarios
const MC_OPTIONS = ['Yes, bread with filling', 'No, its own category', "It's a taco", 'Depends on definition'];

const MC_VOTES_TOP_HIGH = [
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 3 }, { answer: 0, confidence: 2 },
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 },
  { answer: 2, confidence: 3 }, { answer: 2, confidence: 2 },
  { answer: 3, confidence: 4 }, { answer: 3, confidence: 1 },
];

const MC_VOTES_TOP_LOW = [
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 2 }, { answer: 0, confidence: 1 },
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 },
  { answer: 2, confidence: 3 },
  { answer: 3, confidence: 2 },
];

const MC_VOTES_MID_HIGH = [
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 }, { answer: 0, confidence: 3 },
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 },
  { answer: 2, confidence: 4 }, { answer: 2, confidence: 3 },
  { answer: 3, confidence: 3 }, { answer: 3, confidence: 2 },
];

const MC_VOTES_LAST_LOW = [
  { answer: 0, confidence: 4 }, { answer: 0, confidence: 4 }, { answer: 0, confidence: 3 },
  { answer: 0, confidence: 3 }, { answer: 0, confidence: 2 },
  { answer: 1, confidence: 4 }, { answer: 1, confidence: 3 }, { answer: 1, confidence: 2 },
  { answer: 2, confidence: 3 }, { answer: 2, confidence: 2 },
  { answer: 3, confidence: 1 },
];

// MC answer label with pill outline
const renderMCAnswerLabel = (label, isUserRow, color, darkMode) => {
  if (isUserRow) {
    return (
      <span className="text-sm font-semibold px-3 py-1 rounded-full border-2 truncate"
        style={{ color, borderColor: color, maxWidth: '70%' }}>
        {label}
      </span>
    );
  }
  return <span className="text-sm font-medium truncate" style={{ color, maxWidth: '70%' }}>{label}</span>;
};

// MC bar with checkmark inside user's confidence segment
const renderMCConfBarInline = (opt, colors, barWidth, darkMode, userConf, isUserRow) => {
  const getTextColor = (confIdx) => confIdx <= 1 ? '#374151' : 'white';
  const existingSegments = [3, 2, 1, 0].filter(idx => opt.confCounts[idx] > 0);
  const firstSeg = existingSegments[0];
  const lastSeg = existingSegments[existingSegments.length - 1];
  const highlightColor = darkMode ? 'white' : '#6b7280';
  const barBg = darkMode ? 'bg-gray-800' : 'bg-gray-200';

  return (
    <div className={`h-7 rounded-full ${barBg} relative`}>
      <div className="h-full flex rounded-full overflow-hidden relative" style={{ width: `${barWidth}%` }}>
        {[3, 2, 1, 0].map(confIdx => {
          const count = opt.confCounts[confIdx];
          if (count === 0) return null;
          const segWidth = (count / opt.count) * 100;
          const isUserSeg = isUserRow && confIdx === userConf;
          const textColor = getTextColor(confIdx);
          const isFirst = confIdx === firstSeg;
          const isLast = confIdx === lastSeg;
          const segRadius = isFirst && isLast ? '14px' : isFirst ? '14px 0 0 14px' : isLast ? '0 14px 14px 0' : '0';

          return (
            <div key={confIdx} className="h-full relative flex items-center justify-center"
              style={{ width: `${segWidth}%`, background: colors.shades[confIdx] }}>
              {isUserSeg && (
                <>
                  <span className="text-sm font-black px-1 relative z-10" style={{ color: textColor }}>‚úì</span>
                  <div className="absolute inset-0 pointer-events-none"
                    style={{ borderRadius: segRadius, boxShadow: `inset 0 0 0 3px ${highlightColor}` }} />
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

// MC Inline chart component
const MCChartInline = ({ darkMode, theme, votes, userResponse, label, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>{label}</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              {renderMCAnswerLabel(opt.label, isUserRow, colors.hex, darkMode)}
              <span className="text-sm font-bold flex-shrink-0 ml-2" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarInline(opt, colors, barWidth, darkMode, userConf, isUserRow)}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC INLINE1: Top answer, high confidence
const MCChartInline1 = ({ darkMode, theme }) => (
  <MCChartInline darkMode={darkMode} theme={theme}
    votes={MC_VOTES_TOP_HIGH} userResponse={{ answer: 0, confidence: 4 }}
    label="Top answer, high confidence" options={MC_OPTIONS} />
);

// MC INLINE2: Top answer, low confidence
const MCChartInline2 = ({ darkMode, theme }) => (
  <MCChartInline darkMode={darkMode} theme={theme}
    votes={MC_VOTES_TOP_LOW} userResponse={{ answer: 0, confidence: 1 }}
    label="Top answer, low confidence" options={MC_OPTIONS} />
);

// MC INLINE3: Mid-ranked answer, high confidence
const MCChartInline3 = ({ darkMode, theme }) => (
  <MCChartInline darkMode={darkMode} theme={theme}
    votes={MC_VOTES_MID_HIGH} userResponse={{ answer: 2, confidence: 4 }}
    label="Mid-ranked answer, high confidence" options={MC_OPTIONS} />
);

// MC INLINE4: Last answer, low confidence
const MCChartInline4 = ({ darkMode, theme }) => (
  <MCChartInline darkMode={darkMode} theme={theme}
    votes={MC_VOTES_LAST_LOW} userResponse={{ answer: 3, confidence: 1 }}
    label="Last answer, low confidence" options={MC_OPTIONS} />
);

// ============================================================
// MULTIPLE CHOICE CHART VARIATIONS - All keep confidence segments, vary "You" indicator
// ============================================================

// Helper to build MC chart data
const buildMCData = (votes, userResponse, theme, options) => {
  const mcColors = theme.mcColors;
  const data = options.map((label, i) => ({ label, answer: i, confCounts: [0,0,0,0], count: 0 }));
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  allVotes.forEach(v => {
    if (data[v.answer]) {
      data[v.answer].confCounts[v.confidence - 1]++;
      data[v.answer].count++;
    }
  });
  const total = data.reduce((acc, d) => acc + d.count, 0);
  const maxCount = Math.max(...data.map(d => d.count), 1);
  const sorted = [...data].sort((a, b) => b.count - a.count);
  return { data, sorted, total, maxCount, mcColors };
};

// Render MC confidence bar segments with user highlight
const renderMCConfBarWithUser = (opt, colors, barWidth, darkMode, userConf, isUserRow, highlightStyle = 'outline') => {
  return (
    <div className={`h-5 rounded-full overflow-hidden ${darkMode ? 'bg-gray-800' : 'bg-gray-200'}`}>
      <div className="h-full flex" style={{ width: `${barWidth}%` }}>
        {[3, 2, 1, 0].map(confIdx => {
          const count = opt.confCounts[confIdx];
          if (count === 0) return null;
          const segWidth = (count / opt.count) * 100;
          const isUserSeg = isUserRow && confIdx === userConf;

          let segStyle = { width: `${segWidth}%`, background: colors.shades[confIdx] };
          if (isUserSeg) {
            if (highlightStyle === 'outline') {
              segStyle.boxShadow = 'inset 0 0 0 2px white';
            } else if (highlightStyle === 'glow') {
              segStyle.boxShadow = `inset 0 0 0 2px white, 0 0 8px ${colors.shades[confIdx]}`;
            } else if (highlightStyle === 'bright') {
              segStyle.filter = 'brightness(1.3)';
              segStyle.boxShadow = 'inset 0 0 0 2px white';
            }
          }
          return <div key={confIdx} className="h-full relative" style={segStyle}>
            {isUserSeg && highlightStyle === 'arrow' && (
              <div className="absolute -top-2 left-1/2 -translate-x-1/2 text-white text-xs">‚ñº</div>
            )}
          </div>;
        })}
      </div>
    </div>
  );
};

// MC CURRENT: Original design (baseline) - uses basic segment outline
const MCChartCurrent = ({ votes, userResponse, darkMode, theme, options, label = 'Current Design' }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>{label}</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <span className={`text-sm font-medium truncate flex-1 mr-2 ${isUserRow ? 'px-2 py-0.5 rounded-full border' : ''}`}
                style={{ color: colors.hex, borderColor: isUserRow ? colors.hex : 'transparent', maxWidth: '70%' }}>
                {opt.label} {isUserRow && '(You)'}
              </span>
              <span className="text-sm font-bold" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC V1a: Pill + outline on confidence segment
const MCChartV1 = ({ votes, userResponse, darkMode, theme, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1a: Pill + outline on segment</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 flex-1 min-w-0 mr-2">
                <span className="text-sm font-medium truncate" style={{ color: colors.hex }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium flex-shrink-0" style={{ background: colors.hex }}>You</span>}
              </div>
              <span className="text-sm font-bold flex-shrink-0" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC V1e: Pill with confidence text
const MCChartV5 = ({ votes, userResponse, darkMode, theme, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1e: Pill with confidence text</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 flex-1 min-w-0 mr-2">
                <span className="text-sm font-medium truncate" style={{ color: colors.hex }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium flex-shrink-0" style={{ background: colors.hex }}>You ‚Ä¢ {confLabels[userConf]}</span>}
              </div>
              <span className="text-sm font-bold flex-shrink-0" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC V1f: Pill with stars
const MCChartV6 = ({ votes, userResponse, darkMode, theme, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1f: Pill with stars</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 flex-1 min-w-0 mr-2">
                <span className="text-sm font-medium truncate" style={{ color: colors.hex }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium flex-shrink-0" style={{ background: colors.hex }}>You {getStars(userConf + 1)}</span>}
              </div>
              <span className="text-sm font-bold flex-shrink-0" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC V1h: Pill + row highlight + outline
const MCChartV8 = ({ votes, userResponse, darkMode, theme, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>V1h: Pill + row highlight + outline</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer} className="space-y-1 p-2 -mx-2 rounded-lg" style={{ background: isUserRow ? `${colors.hex}10` : 'transparent' }}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 flex-1 min-w-0 mr-2">
                <span className="text-sm font-medium truncate" style={{ color: colors.hex }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2 py-0.5 rounded-full text-white font-medium flex-shrink-0" style={{ background: colors.hex }}>You</span>}
              </div>
              <span className="text-sm font-bold flex-shrink-0" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'outline')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// ============================================================
// BOLD MC VARIATIONS
// ============================================================

// MC BOLD1: Full row background
const MCChartBold1 = ({ votes, userResponse, darkMode, theme, options }) => {
  const { sorted, total, maxCount, mcColors } = buildMCData(votes, userResponse, theme, options);
  const userConf = userResponse ? userResponse.confidence - 1 : -1;
  return (
    <div className="space-y-2">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Bold 1: Full row background</div>
      {sorted.map((opt) => {
        const isUserRow = userResponse?.answer === opt.answer;
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        return (
          <div key={opt.answer}
            className={`p-3 -mx-3 rounded-xl transition-all ${isUserRow ? 'ring-2' : ''}`}
            style={{
              background: isUserRow ? `${colors.hex}15` : 'transparent',
              ringColor: isUserRow ? colors.hex : 'transparent'
            }}>
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center gap-2 flex-1 min-w-0 mr-2">
                <span className="text-sm font-semibold truncate" style={{ color: colors.hex }}>{opt.label}</span>
                {isUserRow && <span className="text-xs px-2.5 py-1 rounded-full text-white font-bold flex-shrink-0" style={{ background: colors.hex }}>YOU</span>}
              </div>
              <span className="text-sm font-bold flex-shrink-0" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            {renderMCConfBarWithUser(opt, colors, barWidth, darkMode, userConf, isUserRow, 'bright')}
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// Placeholder - keeping old component name for compatibility
const BinaryDotSwarm = ({ votes, userResponse, darkMode, theme }) => {
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  const yesVotes = allVotes.filter(v => v.answer === 0);
  const noVotes = allVotes.filter(v => v.answer === 1);
  const total = allVotes.length;
  const yesPct = total > 0 ? Math.round((yesVotes.length / total) * 100) : 0;

  const renderDots = (voteList, baseColor, isYes) => {
    return voteList.map((v, i) => {
      const size = 6 + v.confidence * 2; // 8-14px based on confidence
      const opacity = 0.4 + v.confidence * 0.15;
      const isUser = userResponse && v === userResponse;
      return (
        <div key={i} className="relative" style={{
          width: size, height: size, borderRadius: '50%',
          background: baseColor, opacity,
          boxShadow: isUser ? `0 0 0 2px white, 0 0 8px ${baseColor}` : 'none',
          margin: 2
        }} />
      );
    });
  };

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Dot Swarm (size = confidence)</div>
      <div className="flex gap-6 justify-center">
        <div className="text-center">
          <div className="flex flex-wrap justify-center max-w-[120px] min-h-[40px] mb-2">
            {renderDots(yesVotes, '#10b981', true)}
          </div>
          <div className="text-emerald-500 font-bold">{yesPct}% Yes</div>
        </div>
        <div className={`w-px ${darkMode ? 'bg-gray-700' : 'bg-gray-300'}`} />
        <div className="text-center">
          <div className="flex flex-wrap justify-center max-w-[120px] min-h-[40px] mb-2">
            {renderDots(noVotes, '#f43f5e', false)}
          </div>
          <div className="text-rose-500 font-bold">{100 - yesPct}% No</div>
        </div>
      </div>
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} people ‚Ä¢ Bigger dot = more confident</div>
    </div>
  );
};

// BINARY: Face Crowd - emoji faces grouped by answer
const BinaryFaceCrowd = ({ votes, userResponse, darkMode, theme }) => {
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  const yesVotes = allVotes.filter(v => v.answer === 0);
  const noVotes = allVotes.filter(v => v.answer === 1);
  const total = allVotes.length;
  const yesPct = total > 0 ? Math.round((yesVotes.length / total) * 100) : 0;

  const confToFace = (conf, isYes) => {
    if (isYes) return ['üòê', 'üôÇ', 'üòä', 'ü§©'][conf - 1] || 'üôÇ';
    return ['üòê', 'üôÅ', 'üò£', 'üò§'][conf - 1] || 'üôÅ';
  };

  const renderFaces = (voteList, isYes) => voteList.slice(0, 12).map((v, i) => {
    const isUser = userResponse && v === userResponse;
    return (
      <span key={i} className={`text-lg ${isUser ? 'ring-2 ring-white rounded-full' : ''}`}>
        {confToFace(v.confidence, isYes)}
      </span>
    );
  });

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Face Crowd (expression = confidence)</div>
      <div className="flex gap-4 justify-center">
        <div className="text-center flex-1">
          <div className="flex flex-wrap justify-center gap-0.5 mb-2 min-h-[48px]">
            {renderFaces(yesVotes, true)}
          </div>
          <div className="text-emerald-500 font-bold text-sm">{yesPct}% Yes</div>
        </div>
        <div className={`w-px ${darkMode ? 'bg-gray-700' : 'bg-gray-300'}`} />
        <div className="text-center flex-1">
          <div className="flex flex-wrap justify-center gap-0.5 mb-2 min-h-[48px]">
            {renderFaces(noVotes, false)}
          </div>
          <div className="text-rose-500 font-bold text-sm">{100 - yesPct}% No</div>
        </div>
      </div>
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} people voted</div>
    </div>
  );
};

// BINARY: Split View - clean bars + separate confidence breakdown
const BinarySplitView = ({ votes, userResponse, darkMode, theme }) => {
  const yesColors = theme.confidence.yes;
  const noColors = theme.confidence.no;
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  const yesVotes = allVotes.filter(v => v.answer === 0);
  const noVotes = allVotes.filter(v => v.answer === 1);
  const total = allVotes.length;
  const yesPct = total > 0 ? Math.round((yesVotes.length / total) * 100) : 0;

  const getConfDist = (voteList) => {
    const dist = [0, 0, 0, 0];
    voteList.forEach(v => dist[v.confidence - 1]++);
    return dist;
  };
  const yesDist = getConfDist(yesVotes);
  const noDist = getConfDist(noVotes);

  return (
    <div className="space-y-4">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Split View (answers + confidence separate)</div>

      {/* Main result bar */}
      <div className={`h-10 rounded-xl overflow-hidden flex ${darkMode ? 'bg-gray-800' : 'bg-gray-200'}`}>
        <div className="h-full flex items-center justify-center bg-emerald-500" style={{ width: `${yesPct}%` }}>
          <span className="text-white font-bold text-sm">{yesPct}% Yes</span>
        </div>
        <div className="h-full flex items-center justify-center bg-rose-500" style={{ width: `${100 - yesPct}%` }}>
          <span className="text-white font-bold text-sm">{100 - yesPct}% No</span>
        </div>
      </div>

      {/* Confidence breakdown */}
      <div className={`p-3 rounded-lg ${darkMode ? 'bg-gray-800/50' : 'bg-gray-100'}`}>
        <div className={`text-xs mb-2 ${TH('text-muted', darkMode)}`}>How confident were they?</div>
        <div className="flex gap-4">
          <div className="flex-1">
            <div className="flex gap-1 h-6">
              {yesDist.map((count, i) => (
                <div key={i} className="flex-1 rounded" style={{
                  background: yesColors[i],
                  opacity: count > 0 ? 0.3 + (count / Math.max(...yesDist)) * 0.7 : 0.1
                }} />
              ))}
            </div>
            <div className={`text-xs mt-1 text-center ${TH('text-muted', darkMode)}`}>Yes voters</div>
          </div>
          <div className="flex-1">
            <div className="flex gap-1 h-6">
              {noDist.map((count, i) => (
                <div key={i} className="flex-1 rounded" style={{
                  background: noColors[i],
                  opacity: count > 0 ? 0.3 + (count / Math.max(...noDist)) * 0.7 : 0.1
                }} />
              ))}
            </div>
            <div className={`text-xs mt-1 text-center ${TH('text-muted', darkMode)}`}>No voters</div>
          </div>
        </div>
        <div className={`flex justify-between text-xs mt-2 ${TH('text-subtle', darkMode)}`}>
          <span>Unsure</span><span>Very sure</span>
        </div>
      </div>
    </div>
  );
};

// BINARY: Text Summary - plain language description
const BinaryTextSummary = ({ votes, userResponse, darkMode, theme }) => {
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  const yesVotes = allVotes.filter(v => v.answer === 0);
  const noVotes = allVotes.filter(v => v.answer === 1);
  const total = allVotes.length;
  const yesPct = total > 0 ? Math.round((yesVotes.length / total) * 100) : 0;

  const avgConf = (voteList) => voteList.length > 0
    ? voteList.reduce((s, v) => s + v.confidence, 0) / voteList.length
    : 0;
  const yesConf = avgConf(yesVotes);
  const noConf = avgConf(noVotes);

  const confWord = (c) => c < 1.5 ? 'uncertain' : c < 2.5 ? 'somewhat confident' : c < 3.5 ? 'confident' : 'very confident';
  const winner = yesPct > 50 ? 'Yes' : yesPct < 50 ? 'No' : 'Split';
  const winnerPct = yesPct > 50 ? yesPct : 100 - yesPct;
  const winnerConf = yesPct > 50 ? yesConf : noConf;

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Text Summary</div>
      <div className={`p-4 rounded-xl ${darkMode ? 'bg-gray-800' : 'bg-gray-100'}`}>
        <p className={`text-center ${TH('text-primary', darkMode)}`}>
          <span className="text-2xl font-bold" style={{ color: winner === 'Yes' ? '#10b981' : winner === 'No' ? '#f43f5e' : undefined }}>
            {winnerPct}%
          </span>
          <span className="text-lg"> said </span>
          <span className="text-xl font-semibold" style={{ color: winner === 'Yes' ? '#10b981' : '#f43f5e' }}>
            {winner}
          </span>
        </p>
        <p className={`text-center text-sm mt-2 ${TH('text-muted', darkMode)}`}>
          Most were {confWord(winnerConf)}
        </p>
      </div>
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC: Bubble Chart - size = votes, opacity = confidence
const MCBubbleChart = ({ votes, userResponse, darkMode, theme, options }) => {
  const mcColors = theme.mcColors;
  const data = options.map((label, i) => ({ label, answer: i, confSum: 0, count: 0 }));
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  allVotes.forEach(v => {
    if (data[v.answer]) {
      data[v.answer].confSum += v.confidence;
      data[v.answer].count++;
    }
  });
  data.forEach(d => d.avgConf = d.count > 0 ? d.confSum / d.count : 0);
  const total = data.reduce((acc, d) => acc + d.count, 0);
  const maxCount = Math.max(...data.map(d => d.count), 1);

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Bubble Chart (size = votes, opacity = confidence)</div>
      <div className="flex flex-wrap justify-center gap-3 py-4">
        {data.map((opt, i) => {
          const size = 40 + (opt.count / maxCount) * 50; // 40-90px
          const opacity = 0.4 + (opt.avgConf / 4) * 0.6;
          const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
          const colors = mcColors[i % mcColors.length];
          const isUser = userResponse?.answer === opt.answer;
          return (
            <div key={i} className="flex flex-col items-center">
              <div className="relative flex items-center justify-center" style={{
                width: size, height: size, borderRadius: '50%',
                background: colors.hex, opacity,
                boxShadow: isUser ? `0 0 0 3px white` : 'none'
              }}>
                <span className="text-white font-bold text-sm">{pct}%</span>
              </div>
              <span className={`text-xs mt-1 text-center max-w-[80px] truncate ${TH('text-muted', darkMode)}`}>
                {opt.label.split(' ').slice(0, 2).join(' ')}
              </span>
            </div>
          );
        })}
      </div>
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC: Ranked Pills - clean ranking with confidence indicator
const MCRankedPills = ({ votes, userResponse, darkMode, theme, options }) => {
  const mcColors = theme.mcColors;
  const data = options.map((label, i) => ({ label, answer: i, confSum: 0, count: 0 }));
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  allVotes.forEach(v => {
    if (data[v.answer]) {
      data[v.answer].confSum += v.confidence;
      data[v.answer].count++;
    }
  });
  data.forEach(d => d.avgConf = d.count > 0 ? d.confSum / d.count : 0);
  const total = data.reduce((acc, d) => acc + d.count, 0);
  const sorted = [...data].sort((a, b) => b.count - a.count);

  const confLabel = (c) => c < 2 ? 'unsure' : c < 3 ? 'leaning' : c < 3.5 ? 'confident' : 'certain';

  return (
    <div className="space-y-2">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Ranked Pills</div>
      {sorted.map((opt, rank) => {
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const isUser = userResponse?.answer === opt.answer;
        return (
          <div key={opt.answer} className={`flex items-center gap-2 p-2 rounded-lg ${isUser ? (darkMode ? 'bg-gray-800 ring-1 ring-white/30' : 'bg-gray-100 ring-1 ring-gray-400') : ''}`}>
            <span className={`w-5 text-center font-bold ${rank === 0 ? 'text-amber-400' : TH('text-muted', darkMode)}`}>
              {rank + 1}
            </span>
            <div className="flex-1 min-w-0">
              <div className={`text-sm font-medium truncate ${TH('text-primary', darkMode)}`}>{opt.label}</div>
              {opt.count > 0 && (
                <div className={`text-xs ${TH('text-subtle', darkMode)}`}>mostly {confLabel(opt.avgConf)}</div>
              )}
            </div>
            <div className="text-right">
              <div className="font-bold" style={{ color: colors.hex }}>{pct}%</div>
            </div>
          </div>
        );
      })}
      <div className={`text-center text-xs ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// MC: Waffle Grid - each square is a vote
const MCWaffleGrid = ({ votes, userResponse, darkMode, theme, options }) => {
  const mcColors = theme.mcColors;
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  const total = allVotes.length;

  // Create grid of votes
  const grid = allVotes.map((v, i) => ({
    answer: v.answer,
    confidence: v.confidence,
    isUser: userResponse && v === userResponse
  }));

  return (
    <div className="space-y-3">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Waffle Grid (each square = 1 vote)</div>
      <div className="flex flex-wrap gap-1 justify-center">
        {grid.map((cell, i) => {
          const colors = mcColors[cell.answer % mcColors.length];
          const opacity = 0.4 + cell.confidence * 0.15;
          return (
            <div key={i} style={{
              width: 12, height: 12, borderRadius: 2,
              background: colors.hex, opacity,
              boxShadow: cell.isUser ? '0 0 0 2px white' : 'none'
            }} />
          );
        })}
      </div>
      {/* Legend */}
      <div className="flex flex-wrap justify-center gap-3">
        {options.map((label, i) => {
          const count = allVotes.filter(v => v.answer === i).length;
          const pct = total > 0 ? Math.round((count / total) * 100) : 0;
          return (
            <div key={i} className="flex items-center gap-1">
              <div style={{ width: 10, height: 10, borderRadius: 2, background: mcColors[i % mcColors.length].hex }} />
              <span className={`text-xs ${TH('text-muted', darkMode)}`}>{pct}%</span>
            </div>
          );
        })}
      </div>
    </div>
  );
};

// MC: Simple Clean - just bars, no confidence shown at all
const MCSimpleClean = ({ votes, userResponse, darkMode, theme, options }) => {
  const mcColors = theme.mcColors;
  const data = options.map((label, i) => ({ label, answer: i, count: 0 }));
  const allVotes = userResponse ? [...votes, userResponse] : votes;
  allVotes.forEach(v => { if (data[v.answer]) data[v.answer].count++; });
  const total = data.reduce((acc, d) => acc + d.count, 0);
  const maxCount = Math.max(...data.map(d => d.count), 1);
  const sorted = [...data].sort((a, b) => b.count - a.count);

  return (
    <div className="space-y-2">
      <div className={`text-xs font-medium ${TH('text-muted', darkMode)}`}>Simple Clean (no confidence)</div>
      {sorted.map((opt) => {
        const pct = total > 0 ? Math.round((opt.count / total) * 100) : 0;
        const colors = mcColors[opt.answer % mcColors.length];
        const barWidth = (opt.count / maxCount) * 100;
        const isUser = userResponse?.answer === opt.answer;
        return (
          <div key={opt.answer} className="space-y-1">
            <div className="flex items-center justify-between">
              <span className={`text-sm truncate flex-1 mr-2 ${TH('text-primary', darkMode)}`}>
                {opt.label} {isUser && <span className={`text-xs px-1 rounded ${darkMode ? 'bg-white/10' : 'bg-gray-200'}`}>You</span>}
              </span>
              <span className="text-sm font-bold" style={{ color: colors.hex }}>{pct}%</span>
            </div>
            <div className={`h-3 rounded-full overflow-hidden ${darkMode ? 'bg-gray-800' : 'bg-gray-200'}`}>
              <div className="h-full rounded-full" style={{ width: `${barWidth}%`, background: colors.hex }} />
            </div>
          </div>
        );
      })}
      <div className={`text-center text-xs pt-1 ${TH('text-muted', darkMode)}`}>{total} responses</div>
    </div>
  );
};

// ============================================================
// CHART EXPERIMENTS SCENE (with toggle)
// ============================================================
const ChartExperimentsScene = ({ darkMode, theme, userResponse, mcOptions, mcUserResponse }) => {
  const [chartType, setChartType] = useState('binary'); // 'binary' or 'mc'

  const Card = ({ children }) => (
    <div className={`p-4 rounded-xl ${darkMode ? 'bg-gray-900' : 'bg-white'}`}>{children}</div>
  );

  return (
    <div className={`flex-1 overflow-auto ${darkMode ? 'bg-gray-950' : 'bg-gray-50'}`}>
      {/* Toggle header */}
      <div className={`sticky top-0 z-10 p-3 ${darkMode ? 'bg-gray-950/95' : 'bg-gray-50/95'} backdrop-blur-sm border-b ${darkMode ? 'border-gray-800' : 'border-gray-200'}`}>
        <div className="flex gap-2 justify-center">
          <button onClick={() => setChartType('binary')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${chartType === 'binary' ? 'bg-violet-600 text-white' : (darkMode ? 'bg-gray-800 text-gray-400' : 'bg-gray-200 text-gray-600')}`}>
            Binary (Yes/No)
          </button>
          <button onClick={() => setChartType('mc')}
            className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${chartType === 'mc' ? 'bg-violet-600 text-white' : (darkMode ? 'bg-gray-800 text-gray-400' : 'bg-gray-200 text-gray-600')}`}>
            Multiple Choice
          </button>
        </div>
      </div>

      <div className="p-4 space-y-4">
        {chartType === 'binary' ? (
          <>
            <Card><BinaryChartInline1 darkMode={darkMode} theme={theme} /></Card>
            <Card><BinaryChartInline2 darkMode={darkMode} theme={theme} /></Card>
            <Card><BinaryChartInline3 darkMode={darkMode} theme={theme} /></Card>
            <Card><BinaryChartInline4 darkMode={darkMode} theme={theme} /></Card>
          </>
        ) : (
          <>
            <Card><MCChartInline1 darkMode={darkMode} theme={theme} /></Card>
            <Card><MCChartInline2 darkMode={darkMode} theme={theme} /></Card>
            <Card><MCChartInline3 darkMode={darkMode} theme={theme} /></Card>
            <Card><MCChartInline4 darkMode={darkMode} theme={theme} /></Card>
          </>
        )}
      </div>
    </div>
  );
};

// ============================================================
// PHONE FRAME
// ============================================================
const PhoneFrame = ({ children, darkMode, device }) => {
  const d = DEVICES[device] || DEVICES['iphone-15'];
  return (
    <div className="relative bg-[#1a1a1c] rounded-[55px] p-3 shadow-2xl" style={{ filter: 'drop-shadow(0 25px 50px rgba(0,0,0,0.4))', transform: `scale(${d.scale})`, transformOrigin: 'top center' }}>
      <div className="absolute -left-[3px] top-[100px] w-[3px] h-[28px] bg-[#2a2a2c] rounded-l-sm" />
      <div className="absolute -left-[3px] top-[145px] w-[3px] h-[50px] bg-[#2a2a2c] rounded-l-sm" />
      <div className="absolute -right-[3px] top-[160px] w-[3px] h-[65px] bg-[#2a2a2c] rounded-r-sm" />
      <div className={`relative overflow-hidden flex flex-col ${darkMode ? 'bg-gray-950' : 'bg-gray-100'}`} style={{ width: d.width, height: d.height, borderRadius: 44 }}>
        <div className="absolute top-3 left-1/2 -translate-x-1/2 w-[126px] h-[37px] bg-black rounded-full z-30" />
        <div className={`flex-shrink-0 flex items-end justify-between px-8 pb-2 h-[54px] ${TH('text-primary', darkMode)} text-sm font-semibold relative z-20`}>
          <span>9:41</span>
          <div className="flex gap-1.5 items-center">
            <div className={`w-[25px] h-[12px] border-[1.5px] ${darkMode ? 'border-white' : 'border-gray-900'} rounded-[3px] flex items-center p-[2px]`}>
              <div className={`w-[17px] h-[7px] ${darkMode ? 'bg-white' : 'bg-gray-900'} rounded-[1px]`} />
            </div>
          </div>
        </div>
        <div className="flex-1 flex flex-col overflow-hidden">{children}</div>
        <div className={`absolute bottom-2 left-1/2 -translate-x-1/2 w-[134px] h-[5px] ${darkMode ? 'bg-white' : 'bg-gray-900'} rounded-full opacity-60 z-20`} />
      </div>
    </div>
  );
};

// ============================================================
// PREVIEW CONTENT
// ============================================================
const PreviewContent = ({ scene, theme, darkMode }) => {
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [confidence, setConfidence] = useState(3);
  const stats = { answered: 42, streak: 5 };
  const userResponse = selectedAnswer !== null ? { answer: selectedAnswer, confidence } : { answer: 0, confidence: 3 };

  const handleSelect = (answer) => {
    if (selectedAnswer === answer) setConfidence(Math.min(confidence + 1, 4));
    else { setSelectedAnswer(answer); setConfidence(1); }
  };

  // CATEGORIES (FIXED)
  if (scene === 'categories') {
    return <CategoryBrowserScreen darkMode={darkMode} theme={theme} />;
  }

  // ASSESSMENT COMPLETE (NEW)
  if (scene === 'assessment-complete') {
    return (
      <div className={`flex-1 ${darkMode ? 'bg-gray-950' : 'bg-gray-50'}`}>
        <CompleteModalEnhanced darkMode={darkMode} theme={theme} onViewResults={() => {}} onNextAssessment={() => {}} onExplore={() => {}} />
      </div>
    );
  }

  // CHART EXPERIMENTS (NEW) - with toggle
  if (scene === 'chart-experiments') {
    const mcOptions = ['Yes, bread with filling', 'No, its own category', "It's a taco", 'Depends on definition'];
    const mcUserResponse = { answer: 1, confidence: 3 };

    return <ChartExperimentsScene darkMode={darkMode} theme={theme} userResponse={userResponse} mcOptions={mcOptions} mcUserResponse={mcUserResponse} />;
  }

  // QUESTION FLOW (with chart)
  if (scene === 'question-flow') {
    const q = SAMPLE_QUESTIONS[0];
    return (
      <>
        <NavBar darkMode={darkMode} theme={theme} stats={stats} />
        <div className="flex-1 overflow-auto p-4 space-y-4">
          <div className="flex justify-center"><CategoryChip category={q.category} theme={theme} darkMode={darkMode} /></div>
          <h2 className={`question-text text-center font-medium ${TH('text-primary', darkMode)}`}>{q.text}</h2>
          <BinaryButtons darkMode={darkMode} theme={theme} selectedAnswer={selectedAnswer} confidence={confidence} onSelect={handleSelect} />
          {selectedAnswer !== null && (
            <div className={`p-4 rounded-xl ${darkMode ? 'bg-gray-900' : 'bg-white'}`}>
              <h3 className={`text-sm font-medium mb-3 ${TH('text-muted', darkMode)}`}>Community Results</h3>
              <ChartCurrent votes={SAMPLE_VOTES.binary} userResponse={{ answer: selectedAnswer, confidence }} darkMode={darkMode} theme={theme} />
            </div>
          )}
        </div>
      </>
    );
  }

  return <div className={`flex-1 flex items-center justify-center ${TH('text-muted', darkMode)}`}>Select a scene</div>;
};

// ============================================================
// MAIN APP
// ============================================================
const App = () => {
  const [theme] = useState(DEFAULT_THEME);
  const [darkMode, setDarkMode] = useState(true);
  const [device, setDevice] = useState('iphone-15');
  const [scene, setScene] = useState('chart-experiments');

  const scenes = [
    { id: 'chart-experiments', name: 'Chart Experiments', desc: 'Binary + MC variations' },
    { id: 'categories', name: 'Category Browser', desc: 'Fixed: no left borders' },
    { id: 'assessment-complete', name: 'Assessment Complete', desc: 'Next Assessment = primary CTA' },
    { id: 'question-flow', name: 'Question Flow', desc: 'Test charts in context' },
  ];

  return (
    <div className="min-h-screen bg-gray-950 flex">
      {/* Sidebar */}
      <div className="w-72 bg-gray-900 border-r border-gray-800 p-4 overflow-auto hide-scrollbar">
        <h1 className="text-xl font-bold text-white mb-6">üé® Playground v2</h1>

        <div className="mb-6">
          <label className="flex items-center gap-3 cursor-pointer">
            <span className="text-sm text-gray-400">Light</span>
            <div className={`w-12 h-6 rounded-full p-1 ${darkMode ? 'bg-violet-600' : 'bg-gray-600'}`} onClick={() => setDarkMode(!darkMode)}>
              <div className={`w-4 h-4 rounded-full bg-white transition-transform ${darkMode ? 'translate-x-6' : ''}`} />
            </div>
            <span className="text-sm text-gray-400">Dark</span>
          </label>
        </div>

        <div className="mb-6">
          <h3 className="text-sm font-semibold text-gray-300 mb-2">Scene</h3>
          <div className="space-y-2">
            {scenes.map(s => (
              <button key={s.id} onClick={() => setScene(s.id)}
                className={`w-full text-left px-3 py-2 rounded-lg ${scene === s.id ? 'bg-violet-600 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}`}>
                <div className="font-medium text-sm">{s.name}</div>
                <div className={`text-xs ${scene === s.id ? 'text-violet-200' : 'text-gray-500'}`}>{s.desc}</div>
              </button>
            ))}
          </div>
        </div>

        <div className="p-3 rounded-lg bg-gray-800/50 text-sm text-gray-400">
          <div className="font-medium text-gray-300 mb-2">Changes in v2:</div>
          <ul className="space-y-1 text-xs">
            <li>‚Ä¢ Category browser: no left borders</li>
            <li>‚Ä¢ Complete modal: Next Assessment = CTA</li>
            <li>‚Ä¢ MC chart experiments (5 variations)</li>
            <li>‚Ä¢ Confidence shown via gradient/stars/glow</li>
          </ul>
        </div>
      </div>

      {/* Preview */}
      <div className="flex-1 flex items-start justify-center p-8 pt-16 overflow-auto bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900">
        <PhoneFrame darkMode={darkMode} device={device}>
          <PreviewContent scene={scene} theme={theme} darkMode={darkMode} />
        </PhoneFrame>
      </div>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
